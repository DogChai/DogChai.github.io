{"meta":{"title":"LittleChai的博客","subtitle":null,"description":null,"author":"LittleChai","url":"https://LittleChai.github.io","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-21T02:51:39.869Z","comments":false,"path":"about/index.html","permalink":"https://LittleChai.github.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-21T02:51:39.873Z","comments":false,"path":"bangumi/index.html","permalink":"https://LittleChai.github.io/bangumi/index.html","excerpt":"","text":""},{"title":"book","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-21T02:51:39.876Z","comments":false,"path":"book/index.html","permalink":"https://LittleChai.github.io/book/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2019-06-21T08:10:10.000Z","updated":"2019-10-21T02:51:39.883Z","comments":true,"path":"comment/index.html","permalink":"https://LittleChai.github.io/comment/index.html","excerpt":"","text":"写一句诗 一句是你 一句是我"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-10-21T02:51:39.880Z","comments":false,"path":"client/index.html","permalink":"https://LittleChai.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-10-21T02:51:39.887Z","comments":false,"path":"donate/index.html","permalink":"https://LittleChai.github.io/donate/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-10-21T02:51:39.890Z","comments":false,"path":"lab/index.html","permalink":"https://LittleChai.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-21T02:51:39.894Z","comments":true,"path":"links/index.html","permalink":"https://LittleChai.github.io/links/index.html","excerpt":"","text":""},{"title":"music","date":"2019-06-22T09:05:00.000Z","updated":"2020-08-16T12:33:04.708Z","comments":false,"path":"music/index.html","permalink":"https://LittleChai.github.io/music/index.html","excerpt":"","text":""},{"title":"照片集","date":"2019-06-21T08:10:10.000Z","updated":"2020-08-16T12:56:52.050Z","comments":true,"path":"photo/index.html","permalink":"https://LittleChai.github.io/photo/index.html","excerpt":"","text":".top1 { background-image: url('http://data.littlechai.cn/jinan1.jpg'); } .top2 { background-image: url('http://data.littlechai.cn/jin1.jpg'); } .top3 { background-image: url('http://data.littlechai.cn/li1.jpg'); } .top4 { background-image: url('http://data.littlechai.cn/life00.png'); } 济南之旅 金匮公园 蠡园 生活记录 济南之旅 金匮公园 蠡园 生活记录"},{"title":"照片集","date":"2019-06-21T08:10:10.000Z","updated":"2019-10-21T02:51:39.903Z","comments":true,"path":"photo/济南.html","permalink":"https://LittleChai.github.io/photo/济南.html","excerpt":"","text":".top1 { background-image: url('http://data.littlechai.cn/jinan1.jpg'); } .top2 { background-image: url('http://data.littlechai.cn/jinan2.jpg'); } .top3 { background-image: url('http://data.littlechai.cn/jinan3.jpg'); } .top4 { background-image: url('http://data.littlechai.cn/jinan4.jpg'); } 济南之旅 济南之旅 济南之旅 济南之旅 济南之旅 济南之旅 济南之旅 济南之旅"},{"title":"照片集","date":"2019-06-21T08:10:10.000Z","updated":"2020-08-16T12:58:48.312Z","comments":true,"path":"photo/生活.html","permalink":"https://LittleChai.github.io/photo/生活.html","excerpt":"","text":".top1 { background-image: url('http://data.littlechai.cn/life00.png'); } .top2 { background-image: url('http://data.littlechai.cn/life01.jpg'); } .top3 { background-image: url('http://data.littlechai.cn/life02.jpg'); } 星轨 晚霞 晚霞 星轨 晚霞 晚霞"},{"title":"照片集","date":"2019-06-21T08:10:10.000Z","updated":"2019-10-21T02:51:39.905Z","comments":true,"path":"photo/蠡园.html","permalink":"https://LittleChai.github.io/photo/蠡园.html","excerpt":"","text":".top1 { background-image: url('http://data.littlechai.cn/li1.jpg'); } .top2 { background-image: url('http://data.littlechai.cn/li2.jpg'); } .top3 { background-image: url('http://data.littlechai.cn/li3.jpg'); } .top4 { background-image: url('http://data.littlechai.cn/li4.jpg'); } 蠡园 蠡园 蠡园 蠡园 蠡园 蠡园 蠡园 蠡园"},{"title":"照片集","date":"2019-06-21T08:10:10.000Z","updated":"2019-10-21T02:51:39.907Z","comments":true,"path":"photo/金匮公园.html","permalink":"https://LittleChai.github.io/photo/金匮公园.html","excerpt":"","text":".top1 { background-image: url('http://data.littlechai.cn/jin1.jpg'); } .top2 { background-image: url('http://data.littlechai.cn/jin2.jpg'); } .top3 { background-image: url('http://data.littlechai.cn/jin3.jpg'); } .top4 { background-image: url('http://data.littlechai.cn/jin4.jpg'); } .top5 { background-image: url('http://data.littlechai.cn/jin5.jpg'); } .top6 { background-image: url('http://data.littlechai.cn/jin6.jpg'); } .top7 { background-image: url('http://data.littlechai.cn/jin7.jpg'); } .top8 { background-image: url('http://data.littlechai.cn/jin8.jpg'); } .top9 { background-image: url('http://data.littlechai.cn/jin9.jpg'); } 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园 金匮公园"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-21T02:51:39.911Z","comments":true,"path":"tags/index.html","permalink":"https://LittleChai.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2021年个人规划及目标","slug":"2021年个人规划及目标","date":"2021-02-25T05:15:00.000Z","updated":"2021-02-25T05:59:57.703Z","comments":true,"path":"2021/02/25/2021年个人规划及目标/","link":"","permalink":"https://LittleChai.github.io/2021/02/25/2021年个人规划及目标/","excerpt":"","text":"2020年目标完成度公司1，2年级数学答题页面 基本功能页面都已经完成 正在进行最后的debug修改阶段 ColorPicker(重构) 项目地址：https://color.littlechai.cn 将使用Vue3进行重构 仍然在计划中 小柴日记簿微信小程序(重构) 已改名小柴随心记 已全部采用云开发接口 已上线 音乐网站(重构) 仍在计划中 2021年目标规划继续学习Vue3 &amp; TypeScript重构 ColorPicker &amp; 音乐播放页面运动 &amp; 适当减肥每日英语单词学习打卡 2月 17日 18日 19日 20日 21日 22日 23日 24日 25日 26日 27日 28日 日期 打卡 打卡 打卡 打卡 打卡 打卡 打卡 打卡 打卡","categories":[{"name":"前端","slug":"前端","permalink":"https://LittleChai.github.io/categories/前端/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://LittleChai.github.io/tags/日记/"},{"name":"规划","slug":"规划","permalink":"https://LittleChai.github.io/tags/规划/"}],"author":"LittleChai"},{"title":"Vue常见面试题整理","slug":"vue常见面试题","date":"2020-10-20T15:36:00.000Z","updated":"2020-10-20T16:09:48.137Z","comments":true,"path":"2020/10/20/vue常见面试题/","link":"","permalink":"https://LittleChai.github.io/2020/10/20/vue常见面试题/","excerpt":"","text":"1.什么是Vue的生命周期？Vue实例从创建到销毁的过程，就是生命周期+ 开始创建 -&gt; 初始化数据 -&gt; 编译模版 -&gt; 挂载DOM -&gt; 渲染、更新 -&gt; 渲染、卸载 等一系列过程 2.Vue生命周期的作用是什么？生命周期中有多个事件钩子，可以让我们在控制Vue实例的过程中形成更好的逻辑3.Vue生命周期总共有几个阶段？8个阶段+ beforeCreate 创建前 + created 创建后 + beforeMount 挂载前 + mounted 挂载后 + beforeUpdate 更新前 + updated 更新后 + beforeDestroy 销毁前 + destroyed 销毁后 4.第一次页面加载会触发哪几个钩子？beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted5.DOM渲染在哪几个周期中就已经完成mounted中就已经完成6.生命周期钩子的一些使用方法+ beforeCreate: 可以加loading事件，在加载实例时触发 + created: 初始完成的事件写在这里，这里结束loading事件，异步请求也可以在这调用 + mounted: 挂载元素，获取dom节点 + updated: 如果要对数据统一处理，在这里写相应函数 + beforeDestroy: 可以弹出确认退出的框 + nextTick: 更新数据后立即操作dom 7.v-show与v-if的区别+ v-show 是css的display:block、none切换 + v-if 是完整的销毁和重新创建 + 频繁切换时使用v-show，运行时较少改变可以用v-if，当只需要一次显示隐藏，v-if更加合理 8.开发中常用哪些指令+ v-model: 实现双向绑定 + v-html:可以直接渲染html代码 + v-show、v-if + v-on:click + v-for + v-bind 9.绑定class的数组用法+ 对象方法 v-bind:class=&quot;{&#39;orange&#39;:isOrange,&#39;green&#39;:isGreen}&quot; + 数组方法 v-bind:class=&quot;[class1,class2] + 行内 v-bind:style=&quot;{color:color,fontSize:fontSize+&#39;px&#39;}&quot; 10.路由跳转方式+ 使用router-link标签跳转 + &lt;router-link to=&quot;test&quot;&gt;&lt;/router-link&gt; + &lt;router-link :to=&quot;&#39;test&#39;&quot;&gt;&lt;/router-link&gt; + &lt;router-link :to=&quot;{path: &#39;/test&#39;}&quot;&gt;&lt;/router-link&gt; + &lt;router-link :to=&quot;{name: &#39;test&#39;}&quot;&gt;&lt;/router-link&gt; + this.$router.push({path: &#39;/xxx&#39;, query: {a:1,b:2}}) + this.$router.push({name: &#39;xxx&#39;, params: {a:1,b:2}}) + 使用this.$route 获取值 11.MVVM+ model 代表数据模型 + view 代表ui组件 + viewmodel,viewmodel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步view和model的对象，连接model和view 12.computed 和 watch 有什么区别？computed 是计算属性，也就是计算值，它具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算watch更多是观察作用，类似某些数据的监听回调，没有缓存，用于观察props $emit 或者本组件的值，当数据变化来执行操作。当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为computed，如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。13.Vue组件的scoped属性的作用可以使当前的样式只作用在当前的模块，实现了样式的私有化。14.Vue是渐进式的框架的理解没有多做职责之外的事15.Vue的两个核心是什么？数据驱动：Object.defineProperty存储器属性：getter和setter16.Vue常用修饰符+ v-model.lazy + v-model.number + v-model.trim + .stop + .self + .once 17.v-on可以监听多个方法吗？可以+ v-on=&#39;{click: fn1,mouseenter: fn2}&#39; + @click=&quot;fn1(),fn2()&quot; 18.Vue事件中如何使用event对象+ @click=&quot;fn($event)&quot; 19.比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0因为你改变数据把show变成true,元素并不会立即显示，理所当然也不会获取到动态宽度。正确的做法是先把元素show出来，在$nextTick去执行获取宽度的操作，不知道这样说会不会好理解一点。+ showDom() { this.show = true; this.$nextTick(() =&gt; { //这里获取宽度 }) } 20.Vue组件中data为什么必须是函数？vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。21.Vue中子组件调用父组件的方法+ this.$parent.fn + 父组件传参，子组件使用props接受，然后再调用 + props: { fn: { type: Function, default: null } } 22.vue中keep-alive组件的作用keep-alive 可以使被包含的组件保留当前状态，避免重新渲染。+ 路由部分 { path: &#39;/test&#39;, name: &#39;test&#39;, component: test, meta: { keepAlive: true } } + router-view 部分 &lt;keep-alive&gt; //被缓存的 &lt;router-view v-if=&#39;$route.meta.keepAlive&#39;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; //不被缓存的 &lt;router-view v-if=&#39;!$route.meta.keepAlive&#39;&gt;&lt;/router-view&gt; 23.Vue中如何编写可复用的组件？24.什么是Vue生命周期和生命周期钩子函数25.Vue更新数组时触发视图更新的方法+ this.$set方法 26.webpack编译原理27.Vue等单页面应用及其优缺点+ 缺点： - 不支持低版本浏览器，只支持到IE9 - 不利于SEO优化 - 第一次加载时间较长 + 优点 - 无刷新，提升了用户体验 - 采用组件化思想，代码模块化，可以复用了 28.什么 是Vue的计算属性监听一个或多个值，进行计算并且同步显示更改+ computed: { newValue() { return this.a+this.b } } 29.vue-cli提供几种脚手架模版30.组件中传递数据+ props 父传子 + $emit 子传父 this.$emit(&#39;fn名&#39;,&#39;要传的参数&#39;); 31.vue-router实现路由懒加载+ component: reslove =&gt; require([&#39;@/components/test&#39;],reslove) 32.vue-router的导航钩子，主要用来作用是拦截导航，让它完成跳转或取消33.完整的vue-router导航解析流程34.vue-router如何响应 路由参数 的变化+ watch: { &#39;$route&#39;(to,from) { //做出变化 } } 35.vue-router的几种实例方法以及参数传递+ &lt;router-link to=&quot;test&quot;&gt;&lt;/router-link&gt; + &lt;router-link :to=&quot;&#39;test&#39;&quot;&gt;&lt;/router-link&gt; + &lt;router-link :to=&quot;{path: &#39;/test&#39;}&quot;&gt;&lt;/router-link&gt; + &lt;router-link :to=&quot;{name: &#39;test&#39;}&quot;&gt;&lt;/router-link&gt; + this.$router.push({path: &#39;/xxx&#39;, query: {a:1,b:2}}) + this.$router.push({name: &#39;xxx&#39;, params: {a:1,b:2}}) 36.is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）37.vuex是什么？怎么使用？哪种功能场景使用它？状态管理：state、getter、mutation、action、moudule+ state 存放数据 + getter 获取数据 + mutation 写方法的地方，他是同步事件，使用store.commit()调用 + action 写方法的地方，是异步事件，使用store.dispatch()调用","categories":[{"name":"前端","slug":"前端","permalink":"https://LittleChai.github.io/categories/前端/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://LittleChai.github.io/tags/面试/"}],"author":"LittleChai"},{"title":"面试题合集","slug":"面试题合集","date":"2020-05-10T13:20:00.000Z","updated":"2020-05-28T03:54:51.240Z","comments":true,"path":"2020/05/10/面试题合集/","link":"","permalink":"https://LittleChai.github.io/2020/05/10/面试题合集/","excerpt":"","text":"‘面试题合集’ 题目顺序不分先后小程序传参的三种方法 跳转地址后直接加参数 例如：?id=1 使用系统缓存 wx.setStorageSync 使用app.js中的globalData对象 var app = getApp(); app.globalData.xxx 数组去重有哪些方法 arr.filterlet arr = [111,111,222,333,444,555,555]; let arr2 = arr.filter((item,index) =&gt; { return arr.indexOf(item) === index }) console.log(arr2); // [111,222,333,444,555] new Set([111,111,222,333,444,555,555])let arr = [111,111,222,333,444,555,555]; let arr2 = Array.from(new Set([...arr])) console.log(arr2) // [111,222,333,444,555] for循环算法 let arr = [111,111,222,333,444,555,555]; function distinct(arr) { for (let i=0, len=arr.length; i&lt;len; i++) { for (let j=i+1; j&lt;len; j++) { if (arr[i] == arr[j]) { arr.splice(j, 1); // splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一 len--; j--; } } } return arr } console.log(distinct(arr)) // [111,222,333,444,555] includes()方法let result = [] for (let i of arr) { !result.includes(i) &amp;&amp; result.push(i) } console.log(result) // [111,222,333,444,555] arr.reduce let arr1 = [111,111,222,333,444,555,555]; let arr2 = arr1.reduce((prev,cur,index) =&gt; { prev.includes(cur) ? &#39;&#39; : prev.push(cur) return prev },[]) console.log(arr2) 父组件给子组件传值 // 父组件 &lt;child :val1=&#39;fatherVal1&#39; :val2=&#39;fatherVal2&#39; &gt;&lt;child&gt; data() { return { fatherVal1: &#39;我是父组件的值&#39;, fatherVal2: { &#39;aa&#39;: 1, &#39;cc&#39;: 2 }, } } // 子组件 export default { props: { val1: { type: &#39;string&#39;, default: () =&gt; { return &quot;&quot; } }, val2: { type: &#39;object&#39;, default: ()=&gt; { return &quot;&quot; } } } } 子组件给父组件传值 // 子组件 &lt;button @click=&#39;toFather&#39;&gt;&lt;/button&gt; methods: { toFather() { this.$emit(&#39;fromChild&#39;,&#39;我是子组件传过来的&#39;) } } // 父组件 &lt;child @fromChild=&#39;fn&#39;&gt;&lt;/child&gt; methods: { fn(msg) { console.log(msg) //我是子组件传过来的 } } 彻底搞懂vuex // state.js const state = { num: 1, type: &#39;one&#39; } export default state // mutations.js import state from &#39;./state&#39;; const mutations = { changeNum(state,n) { state.num = n; }, changeType(state,n) { state.type = n; } } export default mutations // getters.js const getters = { getNum(state) { return state.num }, getType(state) { return state.type } } // actions.js import state from &#39;./state&#39; const actions = { changeNum(content,val) { return new Promise((resolve) =&gt; { // 模拟异步 setTimeout(() =&gt; { content.commit(&#39;changeNum&#39;,val) resolve(); },3000) }) } } // index.js import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; import state from &#39;./state&#39; import getters from &#39;./getters&#39; import mutations from &#39;./mutations&#39; import actions from &#39;./actions&#39; Vue.use(Vuex) const store = new Vuex.Store({ state, getters, mutations, actions }) export default store flex 排列元素自适应 &lt;div class=&quot;test_flex&quot;&gt; &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .test_flex { width: 100%; height: 200px; background-color: gray; display: flex; flex-flow: row nowrap; } .flex_child { flex: 1; margin: 10px 0 10px 10px; max-width: 20%; background-color: goldenrod; } .flex_child:last-child { margin-right: 10px; } &lt;/style&gt; vue路由传参 this.$router.push({ name: &#39;a&#39;, params: { val: &#39;参数&#39; } }) // 浏览器地址栏看不到参数 // this.$route.params获取 this.$router.push({ path: &#39;/a&#39;, query: { val: &#39;参数&#39; } }) // 浏览器地址栏可以看到参数 // this.$route.query获取 view-design按需加载npm install babel-plugin-import --save-dev 根目录新建.babelrc文件 // .babelrc { &quot;plugins&quot;: [[&quot;import&quot;, { &quot;libraryName&quot;: &quot;view-design&quot;, &quot;libraryDirectory&quot;: &quot;src/components&quot; }]] } //main.js引入 import { Button, Table } from &#39;view-design&#39;; import &#39;view-design/dist/styles/iview.css&#39;; Vue.component(&#39;Button&#39;, Button); Vue.component(&#39;Table&#39;, Table); 浏览器缓存解决 给文件改名 跨域问题解决 proxy jsonp 后端cors es5声明变量的方法 var es6声明变量的方法 let const function class import mvvm是什么 Model-View-ViewModel的简写 Model：代表数据模型，数据和业务逻辑都在Model层中定义 View：代表UI视图，负责数据的展示 ViewModel：负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作 mvvm对开发者有什么好处 低耦合。 视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写 易用灵活高效 v-model原理 也就是说， v-model=”sth” 是 v-bind:value=”sth” @input=”sth = $event.target.value” 的缩写。 es6哪些新特性 字符串模版 解构 对象字面量写法 箭头函数 字符串查找 inCludes promise class set es7新特新 3 ** 2 求幂运算符 es8新特新 padStart padEnd 前后补充指定字符串 ‘aabbc’.padStart(6,’x’); //xaabbc Object.entries Object.values async await 数组有哪些操作方法 push 后添加 pop 后删除 unshift 开头 shift 开头删除 splice(index,1,xx) 替换或删除数组，改变原数组 slice(start,end) 截取数组，不改变原数组 concat 数组拼接 foreach遍历 arr.reduce arr.map arr.filter 数组过滤 arr.sort 排序 arr.some 如何优化性能 资源压缩合并，减少http请求 异步加载 添加浏览器缓存 使用cdn vue生命周期 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestory destoryed router beforeEach 监听路由，可以进行拦截重定向等操作 小程序跳转方式 navigateTo redirectTo relaunch navigateBack switchTab 小程序生命周期 1、进入A页面：A执行onLoad()–&gt;onShow()–&gt;onReady()； 2、A页面navigateTo B页面：A执行onHide()，B执行onLoad()–&gt;onShow()–&gt;onReady()； 3、B页面返回A页面：B执行onUnload()，A执行onShow()； 4、退出A页面：A执行onUnload()。 v-if v-show区别 v-if按照条件是否渲染，v-show是display的block或none vue几种常见指令 v-for 、 v-if 、v-bind、v-on、v-show、v-else、v-model、v-html es8新特性 async await padStart padEnd Object.entries() 把对象或字符串转成数组 Object.values() vue跨域解决module.exports = { // 是否使用带有浏览器内核编译器的完整构建版本 runtimeCompiler: false, // 基本路径 publicPath: &#39;./&#39;, //map文件 productionSourceMap: false, // 构建时的输出目录 outputDir: &#39;dist&#39;, //放置静态资源的目录 assetsDir: &#39;static&#39;, //html的输出路径 indexPath: &#39;index.html&#39;, // 文件名哈希值 filenameHashing: true, devServer: { host: &#39;192.168.1.108&#39;, port: 8088, https: false, // 自启动浏览器 open: false, // 跨域 proxy: { &#39;/api&#39;: { target: &#39;http://v.juhe.cn&#39;, changeOrigin: true, ws: true, secure: false, pathRewrite: { &#39;^/api&#39;: &#39;&#39; }, disableHostCheck: true } } }, // 清除console.log configureWebpack: (config) =&gt; { if (process.env.NODE_ENV === &#39;production&#39;) { config.optimization.minimizer[0].options.terserOptions.compress.drop_console = true } } } reduce操作方法 // arr 表示原数组； // prev 表示上一次调用回调时的返回值，或者初始值 init; // cur 表示当前正在处理的数组元素； // index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1； // init 表示初始值。 var sum = arr.reduce((prev, cur) =&gt; { return prev + cur; },0); // 重复次数计算 let names = [&#39;AAA&#39;, &#39;BBB&#39;, &#39;CCC&#39;, &#39;DDD&#39;, &#39;AAA&#39;]; let nameNum = names.reduce((pre, cur) =&gt; { cur in pre ? pre[cur] += 1 : pre[cur] = 1 return pre }, {}) console.log(nameNum); // {AAA: 2, BBB: 1, CCC: 1, DDD: 1} //数组去重 let names = [&#39;AAA&#39;, &#39;BBB&#39;, &#39;CCC&#39;, &#39;DDD&#39;, &#39;AAA&#39;]; let nameNum1 = names.reduce((pre, cur, index) =&gt; { pre.includes(cur) ? &#39;&#39; : pre.push(cur) return pre }, []) console.log(nameNum1); // [&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;, &quot;DDD&quot;] //数组对象去重，转为数组 const names2 = [ { name: &#39;AAA&#39; }, { name: &#39;BBB&#39; }, { name: &#39;DDD&#39; }, { name: &#39;CCC&#39; }, { name: &#39;EEE&#39; }, { name: &#39;AAA&#39; }, ]; let nameNum2 = names2.reduce((pre, cur, index) =&gt; { pre.includes(cur.name) ? &#39;&#39; : pre.push(cur.name) return pre }, []) console.log(nameNum2); // [&quot;AAA&quot;, &quot;BBB&quot;, &quot;DDD&quot;, &quot;CCC&quot;, &quot;EEE&quot;] //对象去重 const names2 = [ { name: &#39;AAA&#39; }, { name: &#39;BBB&#39; }, { name: &#39;DDD&#39; }, { name: &#39;CCC&#39; }, { name: &#39;EEE&#39; }, { name: &#39;AAA&#39; }, ] let obj = {} let nameNum3 = names2.reduce((pre, cur) =&gt; { obj[cur.name] ? &#39;&#39; : obj[cur.name] = true &amp;&amp; pre.push(cur) return pre }, []) console.log(nameNum3); // [{ name: &#39;AAA&#39; },{ name: &#39;BBB&#39; },{ name: &#39;DDD&#39; },{ name: &#39;CCC&#39; },{ name: &#39;EEE&#39; }] 状态码 200 404 502 网关错误 500 服务器内部错误 504 请求超时 vue双向数据绑定的原理是什么首先传输对象的双向数据绑定 Object.defineProperty(target, key, decription),在decription中设置get和set属性（此时应注意description中get和set不能与描述属性共存）数组的实现与对象不同。同时运用观察者模式实现wather，用户数据和view视图的更新 闭包的好处 (1)希望一个变量长期驻扎在内存当中(不被垃圾回收机制回收) (2)避免全局变量的污染 (3)私有成员的存在 (4)安全性提高","categories":[{"name":"面试","slug":"面试","permalink":"https://LittleChai.github.io/categories/面试/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://LittleChai.github.io/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://LittleChai.github.io/tags/面试/"},{"name":"技术","slug":"技术","permalink":"https://LittleChai.github.io/tags/技术/"}],"author":"LittleChai"},{"title":"ES6,ES7,ES8常用新特性","slug":"ES6,ES7,ES8常用新特性","date":"2020-03-12T10:55:30.000Z","updated":"2020-03-12T10:55:25.764Z","comments":true,"path":"2020/03/12/ES6,ES7,ES8常用新特性/","link":"","permalink":"https://LittleChai.github.io/2020/03/12/ES6,ES7,ES8常用新特性/","excerpt":"","text":"ES6特性const,let变量关于使用let与const规则: 使用let声明的变量可以重新赋值,但是不能在同一作用域内重新声明 使用const声明的变量必须赋值初始化,但是不能在同一作用域类重新声明也无法重新赋值 let a = 1; const b = 2; 模板字面量在ES6之前,将字符串连接到一起的方法是+或者concat()方法而现在可以使用 `` 语法 //之前 let name = &#39;tom&#39;; let age = 12; let str = name+&#39; is &#39;+age+&#39; years old&#39;; //现在 let name = &#39;tom&#39;; let age = 12; let str = `${name} is ${age} years old`; 解构在ES6中,可以使用解构从数组和对象提取值并赋值给独特的变量解构数组 let arr = [12,23,34]; let [a,b,c] = arr; console.log(a,b,c); //12,23,34 let [a,[b,c],d] = [1,[2,3],4]; // 解构赋值默认值 let [bol = true] = [] //true // 字符串解构赋值 let [a,b,c,d,e,f,g] = &#39;qwertyu&#39;; []表示被解构的数组, a,b,c表示要将数组中的值存储在其中的变量, 在解构数组是, 还可以忽略值, 例如const[a,,c]=arr,忽略b坐标. 解构对象 let obj = { name: &#39;tom&#39;, age: 20, sex: &#39;男&#39; }; let {name,age,sex} = obj; console.log(name,age,sex); //tom,20,男 花括号 { } 表示被解构的对象，name、age 和 sex 表示要将对象中的属性存储到其中的变量 对象字面量简写法 let name = &#39;tom&#39;; let age = 12; let sex = &#39;男&#39;; let people = { name: name, age: age, sex: sex }; console.log(people); /* { age: 12 name: &quot;tom&quot; sex: &quot;男&quot; } */ 使用和所分配的变量名称相同的名称初始化对象时如果属性名称和所分配的变量名称一样，那么就可以从对象属性中删掉这些重复的变量名称。 let name = &#39;tom&#39;; let age = 12; let sex = &#39;男&#39;; let people = {name,age,sex}; console.log(people) /* { age: 12 name: &quot;tom&quot; sex: &quot;男&quot; } */ 简写方法的名称: let gemstone = { name, age, sex, fn() { ... } }; ES6箭头函数 let fn = (a,b) =&gt; { console.log(a,b) } fn(1,2); 字符串查找 let str = &#39;sky&#39;; let strs = &#39;I see a bird in the sky&#39;; strs.inCludes(str) //true //判断开头是否存在 strs.startsWith(str) //判断结尾是否存在 strs.endsWith(str) //复制字符串 str.repeat(2) //skysky 数字验证 //验证是否是数字，整数，小数都可以 Number.isFinite(12) //true Number.isFinite(12.12) //true //NaN验证 Number.isNaN(NaN) //true //判断是否为整数 Number.isInteger(12.12) //false //整数转换 Number.parseInt(12.12) //12 //浮点数转换 Number.parseFloat(12) JSON数组格式转换 let json = { &#39;0&#39;: &#39;one&#39;, &#39;1&#39;: &#39;two&#39;, &#39;2&#39;: &#39;three&#39;, length:3 } let arr = Array.from(json) //[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] let arr =Array.of(3,4,5,6); console.log(arr); //[3,4,5,6] //fill填充 let arr = [1,2,3,4,5]; arr.fill(&#39;add&#39;,2,5); // 3,4,5被填充覆盖 //[1, 2, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;] //for...of循环 let arr = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;]; for(let item of arr) { console.log(item) //one //two //three } // 或得索引和元素 let arr = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;]; for(let [index,item] of arr.entries()) { console.log(index,item) //0,one //1,two //2,three } 抛出错误 if(true) { throw new Error(&#39;出错了&#39;) } 数组遍历 let arr = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;,&#39;five&#39;] //forEach //forEach循环的特点是会自动省略为空的数组元素，相当于直接给我们筛空了。当是有时候也会给我们帮倒忙。 arr.forEach((item,index) =&gt; { console.log(item,index) }) //filter 筛选 let arr2 = arr.filter((item,index) =&gt; { if(item != &#39;three&#39;) { return true; } }) // [&#39;one&#39;,&#39;two&#39;,&#39;four&#39;,&#39;five&#39;] //some arr.some((item,index) =&gt; { console.log(item,index) }) //map arr.map(x=&gt;&#39;a&#39;) 对象比较Object.is() let obj1 = { name: &#39;啦啦啦&#39; } let obj2 = { name: &#39;啦啦啦&#39; } Object.is(obj1.name,obj2.name); //true console.log(+0 === -0); //true console.log(NaN === NaN ); //false console.log(Object.is(+0,-0)); //false console.log(Object.is(NaN,NaN)); //true 对象合并Object.assign() let obj1 = { a: &#39;a1&#39; } let obj2 = { b: &#39;b1&#39; } let obj3 = { c: &#39;c1&#39; } let obj4 = Object.assign(obj1,obj2,obj3) //{a: &quot;a1&quot;, b: &quot;b1&quot;, c: &quot;c1&quot;} set let setArr = new Set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;]) //Set(3) {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;} //会直接去重 // 追加add // 删除delete // 查找has // 清空clear map*** let json = { name: &#39;lalala&#39;, skill: &#39;web&#39; } console.log(json) var map = new Map(); map.set(json,&#39;am&#39;); console.log(map); map.set(&#39;heihei&#39;,json); console.log(map); //增删查 //get console.log(map.get(json)) //am console.log(map.get(&#39;heihei&#39;)) //json //delete删除特定 map.delete(json); //删除全部 map.clear(); //size 返回数量 map.size; //2 //has查找，返回true,false map.has(&#39;heihei&#39;) //true // set(),get(),delete(),clear(),size,has() promise let state = 1; function step1(resolve,reject) { console.log(&#39;第一步&#39;) if(state == 1) { resolve(&#39;ok&#39;) } else { reject(&#39;no&#39;) } } function step2(resolve,reject) { console.log(&#39;第二步&#39;) if(state == 1) { resolve(&#39;ok&#39;) } else { reject(&#39;no&#39;) } } function step3(resolve,reject) { console.log(&#39;第三步&#39;) if(state == 1) { resolve(&#39;ok&#39;) } else { reject(&#39;no&#39;) } } new Promise(step1).then(function(val){ console.log(val) return new Promise(step2); }).then(function(val){ console.log(val) return new Promise(step3); }).then(function(val){ console.log(val) }) class类 class Coder{ constructor(a,b) { this.a = a; this.b = b; } name(val) { console.log(val); return val; } skill(val) { console.log(this.name(&#39;god&#39;),val) } add() { return this.a+this.b; } } let littlechai = new Coder(&#39;aa&#39;,&#39;bb&#39;); littlechai.name(&#39;god&#39;); littlechai.skill(&#39;god&#39;); littlechai.add(); // 继承 class Htmler extends Coder{ } let jicheng = new Htmler; jicheng.name(&#39;haha&#39;) ES7特性Array.prototype.includes()方法includes()方法用来判断一个数组是否包含一个指定的值,根据情况,如果包含则返回true,否则返回falseArray.prototype.includes()方法接收两个参数： 要搜索的值 搜索的开始索引 var arr = [1,3,5,7,9,11,13]; console.log(arr.includes(2)); //false console.log(arr.includes(7)); //true var pets = [&#39;dog&#39;,&#39;cat&#39;,&#39;bird&#39;]; console.log(pets.includes(&#39;cat&#39;)); //true console.log(pets.includes(&#39;ca&#39;)); //false 当第二个参数被传入时，该方法会从索引处开始往后搜索（默认索引值为0）。若搜索值在数组中存在则返回true，否则返回false。 且看下面示例： [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;].includes(&#39;b&#39;) // true [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;].includes(&#39;b&#39;, 1) // true [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;].includes(&#39;b&#39;, 2) // false NaN的判断。如果数组中有NaN，你又正好需要判断数组是否有存在NaN，这时你使用indexOf是无法判断的，你必须使用includes这个方法。 var ary1 = [NaN]; console.log(ary1.indexOf(NaN))//-1 console.log(ary1.includes(NaN))//true 当数组的有空的值的时候，includes会认为空的值是undefined，而indexOf不会。 var ary1 = new Array(3); console.log(ary1.indexOf(undefined));//-1 console.log(ary1.includes(undefined))//true 求幂运算符(**)通常求幂运算是用Math.pow()方法,但现在可以使用** 3 ** 5 //243 Math.pow(3,5) //243 //还支持以下操作 let n = 3; n **= 5; //243 ES8特性Async FunctionsAsync Functions也就是我们常说的Async/Await，Async/Await是一种用于处理JS异步操作的语法糖，可以帮助我们摆脱回调地狱，编写更加优雅的代码。通俗的理解，async关键字的作用是告诉编译器对于标定的函数要区别对待。当编译器遇到标定的函数中的await关键字时，要暂时停止运行，带到await标定的函数处理完毕后，再进行相应操作。用普通promise写法来做对比： async function asyncFunc() { const result = await fn(); console.log(result); } function asyncFunc() { return fn() .then(result =&gt; { console.log(result); }); } 按顺序处理 async function asyncFunc() { const result1 = await fn1(); console.log(result1); const result2 = await fn2(); console.log(result2); } function asyncFunc() { return fn1() .then(result1 =&gt; { console.log(result1); return fn2(); }) .then(result2 =&gt; { console.log(result2); }); } 并行处理多个异步函数 async function asyncFunc() { const [result1, result2] = await Promise.all([ fn1(), fn2(), ]); console.log(result1, result2); } function asyncFunc() { return Promise.all([ fn1(), fn2(), ]) .then([result1, result2] =&gt; { console.log(result1, result2); }); } 错误处理 async function asyncFunc() { try { await fn(); } catch (err) { console.error(err); } } function asyncFunc() { return fn() .catch(err =&gt; { console.error(err); }); } Object.values and Object.entriesObject.values() 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于for-in循环枚举原型链中的属性 )。obj参数是需要待操作的对象。可以是一个对象，或者一个数组（是一个带有数字下标的对象，[10,20,30] -&gt; {0: 10,1: 20,2: 30})。 let obj = { x: &#39;aaa&#39;, y: 1 }; Object.values(obj); //[&#39;aaa&#39;,1] let obj = [&#39;e&#39;,&#39;s&#39;,&#39;8&#39;] //相当于 {0:&#39;e&#39;,1:&#39;s&#39;,2:&#39;8&#39;}; Object.values(obj); //[&#39;e&#39;,&#39;s&#39;,&#39;8&#39;] // 当我们使用数字键值时，返回的是数字排序 // 根据键值排序 let obj = { 10: &#39;ccc&#39;, 3: &#39;ddd&#39;, 1: &#39;aaa&#39; } Object.values(obj) //[&#39;aaa&#39;,&#39;ddd&#39;,&#39;ccc&#39;] Object.values(&#39;es8&#39;); // [&#39;e&#39;, &#39;s&#39;, &#39;8&#39;] Object.entries 方法返回一个给定对象自身可遍历属性 [key, value] 的数组， 排序规则和 Object.values 一样。这个方法的声明比较琐碎: let obj = {a: &#39;aaa&#39;, b: 2} Object.entries(obj) //[[&#39;a&#39;,&#39;aaa&#39;],[&#39;b&#39;,2]] let obj = [&#39;e&#39;,&#39;s&#39;,&#39;8&#39;] Object.entries(obj) //[[&#39;0&#39;,&#39;e&#39;],[&#39;1&#39;,&#39;s&#39;],[&#39;2&#39;,&#39;8&#39;]] let obj = { 10: &#39;xxx&#39;, 1: &#39;yyy&#39;, 3: &#39;zzz&#39; }; Object.entries(obj); // [[&#39;1&#39;, &#39;yyy&#39;], [&#39;3&#39;, &#39;zzz&#39;], [&#39;10&#39;: &#39;xxx&#39;]] Object.entries(&#39;es8&#39;); // [[&#39;0&#39;, &#39;e&#39;], [&#39;1&#39;, &#39;s&#39;], [&#39;2&#39;, &#39;8&#39;]] String padding为String对象增加了两个函数: padStart和padEnd像它们名字那样，这几个函数的主要目的就是填补字符串的首部和尾部，为了使得到的结果字符串的长度能达到给定的长度。你可以通过特定的字符，或者字符串，或者默认的空格填充它。下面是函数的声明： str.padStart(targetLength,空格||padString) str.padEnd(targetLength,空格||padString) 这些函数的第一个参数是 targetLength（目标长度），这个是结果字符串的长度。第二个参数是可选的 padString（填充字符），一个用于填充到源字符串的字符串。默认值是空格。 &#39;es8&#39;.padStart(2); // &#39;es8&#39; &#39;es8&#39;.padStart(5); // &#39; es8&#39; &#39;es8&#39;.padStart(6, &#39;woof&#39;); // &#39;wooes8&#39; &#39;es8&#39;.padStart(14, &#39;wow&#39;); // &#39;wowwowwowwoes8&#39; &#39;es8&#39;.padStart(7, &#39;0&#39;); // &#39;0000es8&#39; &#39;es8&#39;.padEnd(2); // &#39;es8&#39; &#39;es8&#39;.padEnd(5); // &#39;es8 &#39; &#39;es8&#39;.padEnd(6, &#39;woof&#39;); // &#39;es8woo&#39; &#39;es8&#39;.padEnd(14, &#39;wow&#39;); // &#39;es8wowwowwowwo&#39; &#39;es8&#39;.padEnd(7, &#39;6&#39;); // &#39;es86666&#39;","categories":[{"name":"技术","slug":"技术","permalink":"https://LittleChai.github.io/categories/技术/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://LittleChai.github.io/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"https://LittleChai.github.io/tags/笔记/"}],"author":"LittleChai"},{"title":"H5踩坑记录","slug":"H5踩坑记录","date":"2019-11-04T08:10:00.000Z","updated":"2019-11-04T08:51:27.848Z","comments":true,"path":"2019/11/04/H5踩坑记录/","link":"","permalink":"https://LittleChai.github.io/2019/11/04/H5踩坑记录/","excerpt":"","text":"IOS端position:fixed、input同时使用的问题 IOS端下使用fixed定位时，如果页面存在input输入框，在输入完成以后会导致键盘占用页面的位置(虽然看起来键盘已经缩回去，但是实际上还是会存在于页面中，引起页面无法点击的bug，起初我还以为是代码逻辑问题。) 解决方法：使用absolute或者relative定位 ios端页面滚动不顺畅的问题 header标签添加以下代码&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt; 安卓端华为手机上传文件问题 华为某些机型无法选择图片上传 解决方法: 换手机","categories":[{"name":"技术","slug":"技术","permalink":"https://LittleChai.github.io/categories/技术/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://LittleChai.github.io/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"https://LittleChai.github.io/tags/笔记/"}],"author":"LittleChai"},{"title":"常见面试题整理","slug":"常见面试题整理","date":"2019-11-04T02:00:00.000Z","updated":"2019-11-04T08:52:53.868Z","comments":true,"path":"2019/11/04/常见面试题整理/","link":"","permalink":"https://LittleChai.github.io/2019/11/04/常见面试题整理/","excerpt":"","text":"javascript面试题Vue框架使用Vue的好处 Vue两大特点：响应式编程、组件化。 Vue优势：轻量级框架、简单易学、双向数据绑定、组件化、视图、数据和结构的分离、虚拟dom、运行速度快。 MVVM定义 MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。 Vue生命周期 beforeCreate(创建前)：在数据观测和初始化事件还未开始。 created(创建后)：完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来。 beforeMount(载入前)：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下配置：编译模版，把data里面的数据和模版生成html。注意此时还没有挂载html到页面上。 mounted(载入后)： 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。 beforeUpdate(更新前)：在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated(更新后)：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy(销毁前)： 在实例销毁之前调用。实例仍然完全可用。 destroyed(销毁后)：在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 Vue的响应式原理 当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 第一次页面加载会触发哪几个钩子？ 触发 下面这几个beforeCreate, created, beforeMount, mounted ，并在mounted的时候DOM渲染完成。 Vue中data必须是一个函数 对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。 Vue中做数据渲染的时候如何保证将数据原样输出？ v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出。 v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染。 ｛｛｝｝：插值表达式，可以直接获取Vue实例中定义的数据或函数，使用插值表达式的时候，值可能闪烁；而使用v-html、v-text不会闪烁，有值就显示，没值就隐藏。 active-class是哪个组件的属性？ vue-router模块的router-link组件。 vue-router有哪几种导航钩子？ 第一种：全局导航钩子 router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。 第二种：组件内的钩子 第三种：单独路由独享组件 $route和$router的区别 $route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等 vue几种常用的指令 v-for 、 v-if 、v-bind、v-on、v-show、v-else、v-model、v-html v-if 和 v-show 区别 v-if按照条件是否渲染，v-show是display的block或none vue常用的修饰符？ .prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用 vue-loader是什么？用途有哪些？ 解析.vue文件的一个加载器，跟template/js/style转换成js模块。 用途：js可以写es6、style样式可以scss或less、template可以加jade等 computed、watch、methods的区别 computed计算属性是用来声明式的描述一个值依赖了其它的值。当你在模板里把数据绑定到一个计算属性上时，Vue 会在其依赖的任何值导致该计算属性改变时更新 DOM。这个功能非常强大，它可以让你的代码更加声明式、数据驱动并且易于维护。 watch监听的是你定义的变量,当你定义的变量的值发生变化时，调用对应的方法。就好在div写一个表达式name，data里写入num和lastname,firstname,在watch里当num的值发生变化时，就会调用num的方法，方法里面的形参对应的是num的新值和旧值，而计算属性computed,计算的是Name依赖的值,它不能计算在data中已经定义过的变量。 methods方法，函数，绑定事件调用；不会使用缓存 什么是js的冒泡？如何阻止冒泡事件？ js冒泡概念：当父元素内多级子元素绑定了同一个事件，js会依次从内往外或者从外往内（？）执行每个元素的该事件，从而引发冒泡 js解决冒泡：event.stopPropagation() vue解决冒泡： 事件.stop,例如：@click.stop=”” ,@mouseover.stop=”” vue 组件通信 父组件与子组件传值 父组件传给子组件：子组件通过props方法接受数据; //父组件 father.vue &lt;template&gt; &lt;child :msg=&quot;message&quot;&gt;&lt;/child&gt; &lt;/template&gt; &lt;script&gt; import child from &#39;./child.vue&#39;; export default { components: { child }, data () { return { message: &#39;father message&#39;; } } } &lt;/script&gt; // 子组件 child.vue &lt;template&gt; &lt;div&gt;{{msg}}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { msg: { type: String, required: true } } } &lt;/script&gt; 子组件传给父组件：$emit方法传递参数 // 父组件 father.vue &lt;template&gt; &lt;child @msgFunc=&quot;func&quot;&gt;&lt;/child&gt; &lt;/template&gt; &lt;script&gt; import child from &#39;./child.vue&#39;; export default { components: { child }, methods: { func (msg) { console.log(msg); } } } &lt;/script&gt; // 子组件 child.vue &lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt;点我&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { props: { msg: { type: String, required: true } }, methods () { handleClick () { //........ this.$emit(&#39;msgFunc&#39;); } } } &lt;/script&gt; 非父子组件间的数据传递，兄弟组件传值 eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。也可使用vuex Vue子组件调用父组件的方法 第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法 第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。 的作用是什么？ 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。 大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染 $nextTick是什么？ vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。 Promise对象是什么？ Promise是异步编程的一种解决方案，它是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。promise对象是一个构造函数，用来生成Promise实例。 promise的两个特点 对象状态不受外界影响 &amp;&amp; 一旦状态改变，就不会再变，任何时候都可以得到结果（pending状态–&gt;fulfilled || pending–&gt;rejected）。 axios的特点有哪些？ axios是一个基于promise的HTTP库，支持promise的所有API； 它可以拦截请求和响应； 它可以转换请求数据和响应数据，并对响应回来的内容自动转换为json类型的数据； 它安全性更高，客户端支持防御XSRF； vue中的 ref 是什么？ ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。 vue如何兼容ie babel-polyfill插件 vuex是什么？ vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新 它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性 Vuex有5种属性: 分别是 state、getter、mutation、action、module; state Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations mutations定义的方法动态修改Vuex 的 store 中的状态或数据。 getters 类似vue的计算属性，主要用来过滤一些数据。 action actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。 使用Vuex解决非父子组件之间通信问题 vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题。 vuex 作为数据存储中心 vuex 的 State 在单页应用的开发中本身具有一个“数据库”的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理： 组件之间全局共享的数据 通过后端异步请求的数据 比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态。 页面刷新vuex被清空解决办法？ localStorage 存储到本地再回去 重新获取接口获取数据 Vue、Angular、React的区别？ 与AngularJS的区别 相同点： 都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。 不同点： AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。 与React的区别 相同点： React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。 不同点： React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。 localstorage和sessionstorage是什么?区别? localstorage和sessionstorage一样都是用来存储客户端临时信息的对象，他们均只能存储字符串类型对象 localstorage生命周期是永久的，这意味着除非用户在浏览器提供的UI上清除localstorage信息，否则这些信息将永远存在。 sessionstorage生命周期为当前窗口或标签，一旦窗口或标签被永久关闭了，那么所有通过sessionstorage存储的数据也将被清空。 不同浏览器无法共享localstorage或sessionstorage中的信息。相同浏览器的不同页面可以共享相同的localstorage（页面属于相同的域名和端口），但是不同页面或标签间无法共享sessionstorage。这里需要注意的是，页面及标签仅指顶级窗口，如果一个标签页包含多个iframe标签他们属于同源页面，那么他们之间是可以共享sessionstorage的。 为什么要进行前后端分离？优势？劣势？ 优点：前端专门负责前端页面和特效的编写，后端专门负责后端业务逻辑的处理，前端追求的是页面美观、页面流畅、页面兼容等。后端追求的是三高（高并发、高可用、高性能）让他们各自负责各自的领域，让专业的人负责处理专业的事情，提高开发效率。 缺点： 当接口发生改变的时候，前后端都需要改变。 当发生异常的时候，前后端需要联调–联调是非常浪费时间的。","categories":[{"name":"技术","slug":"技术","permalink":"https://LittleChai.github.io/categories/技术/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://LittleChai.github.io/tags/前端/"},{"name":"笔记","slug":"笔记","permalink":"https://LittleChai.github.io/tags/笔记/"}],"author":"LittleChai"},{"title":"这里是LittleChai的博客","slug":"这里是LittleChai的博客","date":"2019-06-22T08:22:00.000Z","updated":"2019-10-21T02:51:39.866Z","comments":true,"path":"2019/06/22/这里是LittleChai的博客/","link":"","permalink":"https://LittleChai.github.io/2019/06/22/这里是LittleChai的博客/","excerpt":"","text":"感谢 感谢honjun大佬移植的主题 修改在此主题基础上我进行了一些修改 全局的颜色由原先的橙色替换成 -&gt; 樱花色 顶部header高度修改,默认颜色修改，字体大小修改 顶部导航信息修改 首页背景遮罩删除,背景重新定位 首页视频播放按钮删除 文章视频版块删除 优化aplyer播放器宽度位置 底部显示内容精简 个人简介精简 markdown文章样式部分排版重写优化 移动端 按钮大小调整 文章位置改变，添加阴影 侧边栏图标宽度整体增加,列宽度增加,底部信息下移 优化播放器位置显示不全的问题 番组模块显示优化 书集应用此模块二次修改 图集样式重写 优化&amp;新增 优化某些情况图片不显示的问题 新增valine评论插件","categories":[{"name":"生活","slug":"生活","permalink":"https://LittleChai.github.io/categories/生活/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://LittleChai.github.io/tags/笔记/"}],"author":"LittleChai"}]}