<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LittleChai的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://LittleChai.github.io/"/>
  <updated>2021-02-25T05:59:57.703Z</updated>
  <id>https://LittleChai.github.io/</id>
  
  <author>
    <name>LittleChai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021年个人规划及目标</title>
    <link href="https://LittleChai.github.io/2021/02/25/2021%E5%B9%B4%E4%B8%AA%E4%BA%BA%E8%A7%84%E5%88%92%E5%8F%8A%E7%9B%AE%E6%A0%87/"/>
    <id>https://LittleChai.github.io/2021/02/25/2021年个人规划及目标/</id>
    <published>2021-02-25T05:15:00.000Z</published>
    <updated>2021-02-25T05:59:57.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2020年目标完成度"><a href="#2020年目标完成度" class="headerlink" title="2020年目标完成度"></a>2020年目标完成度</h3><h4 id="公司1，2年级数学答题页面"><a href="#公司1，2年级数学答题页面" class="headerlink" title="公司1，2年级数学答题页面"></a>公司1，2年级数学答题页面</h4><ul><li>基本功能页面都已经完成</li><li>正在进行最后的debug修改阶段<br><br></li></ul><h4 id="ColorPicker-重构"><a href="#ColorPicker-重构" class="headerlink" title="ColorPicker(重构)"></a>ColorPicker(重构)</h4><ul><li>项目地址：<a href="https://color.littlechai.cn" target="_blank" rel="noopener">https://color.littlechai.cn</a></li><li>将使用Vue3进行重构</li><li>仍然在计划中<br><br></li></ul><h4 id="小柴日记簿微信小程序-重构"><a href="#小柴日记簿微信小程序-重构" class="headerlink" title="小柴日记簿微信小程序(重构)"></a>小柴日记簿微信小程序(重构)</h4><ul><li>已改名小柴随心记</li><li>已全部采用云开发接口</li><li>已上线<br><br></li></ul><h4 id="音乐网站-重构"><a href="#音乐网站-重构" class="headerlink" title="音乐网站(重构)"></a>音乐网站(重构)</h4><ul><li>仍在计划中<br><br></li></ul><h3 id="2021年目标规划"><a href="#2021年目标规划" class="headerlink" title="2021年目标规划"></a>2021年目标规划</h3><h4 id="继续学习Vue3-amp-TypeScript"><a href="#继续学习Vue3-amp-TypeScript" class="headerlink" title="继续学习Vue3 &amp; TypeScript"></a>继续学习Vue3 &amp; TypeScript</h4><h4 id="重构-ColorPicker-amp-音乐播放页面"><a href="#重构-ColorPicker-amp-音乐播放页面" class="headerlink" title="重构 ColorPicker &amp; 音乐播放页面"></a>重构 ColorPicker &amp; 音乐播放页面</h4><h4 id="运动-amp-适当减肥"><a href="#运动-amp-适当减肥" class="headerlink" title="运动 &amp; 适当减肥"></a>运动 &amp; 适当减肥</h4><h4 id="每日英语单词学习打卡"><a href="#每日英语单词学习打卡" class="headerlink" title="每日英语单词学习打卡"></a>每日英语单词学习打卡</h4><table><thead><tr><th style="text-align:center">2月</th><th style="text-align:center">17日</th><th style="text-align:center">18日</th><th style="text-align:center">19日</th><th style="text-align:center">20日</th><th style="text-align:center">21日</th><th style="text-align:center">22日</th><th style="text-align:center">23日</th><th style="text-align:center">24日</th><th style="text-align:center">25日</th><th style="text-align:center">26日</th><th style="text-align:center">27日</th><th style="text-align:center">28日</th></tr></thead><tbody><tr><td style="text-align:center">日期</td><td style="text-align:center">打卡</td><td style="text-align:center">打卡</td><td style="text-align:center">打卡</td><td style="text-align:center">打卡</td><td style="text-align:center">打卡</td><td style="text-align:center">打卡</td><td style="text-align:center">打卡</td><td style="text-align:center">打卡</td><td style="text-align:center">打卡</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      2021年个人规划及目标
    
    </summary>
    
      <category term="前端" scheme="https://LittleChai.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="日记" scheme="https://LittleChai.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="规划" scheme="https://LittleChai.github.io/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Vue常见面试题整理</title>
    <link href="https://LittleChai.github.io/2020/10/20/vue%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://LittleChai.github.io/2020/10/20/vue常见面试题/</id>
    <published>2020-10-20T15:36:00.000Z</published>
    <updated>2020-10-20T16:09:48.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是Vue的生命周期？"><a href="#1-什么是Vue的生命周期？" class="headerlink" title="1.什么是Vue的生命周期？"></a>1.什么是Vue的生命周期？</h2><h3 id="Vue实例从创建到销毁的过程，就是生命周期"><a href="#Vue实例从创建到销毁的过程，就是生命周期" class="headerlink" title="Vue实例从创建到销毁的过程，就是生命周期"></a>Vue实例从创建到销毁的过程，就是生命周期</h3><pre><code>+ 开始创建 -&gt; 初始化数据 -&gt; 编译模版 -&gt; 挂载DOM -&gt; 渲染、更新 -&gt; 渲染、卸载  等一系列过程 </code></pre><h2 id="2-Vue生命周期的作用是什么？"><a href="#2-Vue生命周期的作用是什么？" class="headerlink" title="2.Vue生命周期的作用是什么？"></a>2.Vue生命周期的作用是什么？</h2><h3 id="生命周期中有多个事件钩子，可以让我们在控制Vue实例的过程中形成更好的逻辑"><a href="#生命周期中有多个事件钩子，可以让我们在控制Vue实例的过程中形成更好的逻辑" class="headerlink" title="生命周期中有多个事件钩子，可以让我们在控制Vue实例的过程中形成更好的逻辑"></a>生命周期中有多个事件钩子，可以让我们在控制Vue实例的过程中形成更好的逻辑</h3><h2 id="3-Vue生命周期总共有几个阶段？"><a href="#3-Vue生命周期总共有几个阶段？" class="headerlink" title="3.Vue生命周期总共有几个阶段？"></a>3.Vue生命周期总共有几个阶段？</h2><h3 id="8个阶段"><a href="#8个阶段" class="headerlink" title="8个阶段"></a>8个阶段</h3><pre><code>+ beforeCreate 创建前+ created  创建后+ beforeMount 挂载前+ mounted 挂载后+ beforeUpdate 更新前+ updated 更新后+ beforeDestroy 销毁前+ destroyed 销毁后</code></pre><h2 id="4-第一次页面加载会触发哪几个钩子？"><a href="#4-第一次页面加载会触发哪几个钩子？" class="headerlink" title="4.第一次页面加载会触发哪几个钩子？"></a>4.第一次页面加载会触发哪几个钩子？</h2><h3 id="beforeCreate-gt-created-gt-beforeMount-gt-mounted"><a href="#beforeCreate-gt-created-gt-beforeMount-gt-mounted" class="headerlink" title="beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted"></a>beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted</h3><h2 id="5-DOM渲染在哪几个周期中就已经完成"><a href="#5-DOM渲染在哪几个周期中就已经完成" class="headerlink" title="5.DOM渲染在哪几个周期中就已经完成"></a>5.DOM渲染在哪几个周期中就已经完成</h2><h3 id="mounted中就已经完成"><a href="#mounted中就已经完成" class="headerlink" title="mounted中就已经完成"></a>mounted中就已经完成</h3><h2 id="6-生命周期钩子的一些使用方法"><a href="#6-生命周期钩子的一些使用方法" class="headerlink" title="6.生命周期钩子的一些使用方法"></a>6.生命周期钩子的一些使用方法</h2><pre><code>+ beforeCreate: 可以加loading事件，在加载实例时触发+ created: 初始完成的事件写在这里，这里结束loading事件，异步请求也可以在这调用+ mounted: 挂载元素，获取dom节点+ updated: 如果要对数据统一处理，在这里写相应函数+ beforeDestroy: 可以弹出确认退出的框+ nextTick: 更新数据后立即操作dom</code></pre><h2 id="7-v-show与v-if的区别"><a href="#7-v-show与v-if的区别" class="headerlink" title="7.v-show与v-if的区别"></a>7.v-show与v-if的区别</h2><pre><code>+ v-show 是css的display:block、none切换+ v-if 是完整的销毁和重新创建+ 频繁切换时使用v-show，运行时较少改变可以用v-if，当只需要一次显示隐藏，v-if更加合理</code></pre><h2 id="8-开发中常用哪些指令"><a href="#8-开发中常用哪些指令" class="headerlink" title="8.开发中常用哪些指令"></a>8.开发中常用哪些指令</h2><pre><code>+ v-model: 实现双向绑定+ v-html:可以直接渲染html代码+ v-show、v-if+ v-on:click+ v-for+ v-bind</code></pre><h2 id="9-绑定class的数组用法"><a href="#9-绑定class的数组用法" class="headerlink" title="9.绑定class的数组用法"></a>9.绑定class的数组用法</h2><pre><code>+ 对象方法 v-bind:class=&quot;{&#39;orange&#39;:isOrange,&#39;green&#39;:isGreen}&quot;+ 数组方法 v-bind:class=&quot;[class1,class2]+ 行内 v-bind:style=&quot;{color:color,fontSize:fontSize+&#39;px&#39;}&quot;</code></pre><h2 id="10-路由跳转方式"><a href="#10-路由跳转方式" class="headerlink" title="10.路由跳转方式"></a>10.路由跳转方式</h2><pre><code>+ 使用router-link标签跳转+ &lt;router-link to=&quot;test&quot;&gt;&lt;/router-link&gt;+ &lt;router-link :to=&quot;&#39;test&#39;&quot;&gt;&lt;/router-link&gt;+ &lt;router-link :to=&quot;{path: &#39;/test&#39;}&quot;&gt;&lt;/router-link&gt;+ &lt;router-link :to=&quot;{name: &#39;test&#39;}&quot;&gt;&lt;/router-link&gt;+ this.$router.push({path: &#39;/xxx&#39;, query: {a:1,b:2}})+ this.$router.push({name: &#39;xxx&#39;, params: {a:1,b:2}})+ 使用this.$route 获取值</code></pre><h2 id="11-MVVM"><a href="#11-MVVM" class="headerlink" title="11.MVVM"></a>11.MVVM</h2><pre><code>+ model 代表数据模型+ view 代表ui组件+ viewmodel,viewmodel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步view和model的对象，连接model和view</code></pre><h2 id="12-computed-和-watch-有什么区别？"><a href="#12-computed-和-watch-有什么区别？" class="headerlink" title="12.computed 和 watch 有什么区别？"></a>12.computed 和 watch 有什么区别？</h2><h3 id="computed-是计算属性，也就是计算值，它具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算"><a href="#computed-是计算属性，也就是计算值，它具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算" class="headerlink" title="computed 是计算属性，也就是计算值，它具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算"></a>computed 是计算属性，也就是计算值，它具有缓存性，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时重新调用对应的getter来计算</h3><h3 id="watch更多是观察作用，类似某些数据的监听回调，没有缓存，用于观察props-emit-或者本组件的值，当数据变化来执行操作。"><a href="#watch更多是观察作用，类似某些数据的监听回调，没有缓存，用于观察props-emit-或者本组件的值，当数据变化来执行操作。" class="headerlink" title="watch更多是观察作用，类似某些数据的监听回调，没有缓存，用于观察props $emit 或者本组件的值，当数据变化来执行操作。"></a>watch更多是观察作用，类似某些数据的监听回调，没有缓存，用于观察props $emit 或者本组件的值，当数据变化来执行操作。</h3><h3 id="当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为computed，如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。"><a href="#当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为computed，如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。" class="headerlink" title="当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为computed，如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。"></a>当我们要进行数值计算，而且依赖于其他数据，那么把这个数据设计为computed，如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。</h3><h2 id="13-Vue组件的scoped属性的作用"><a href="#13-Vue组件的scoped属性的作用" class="headerlink" title="13.Vue组件的scoped属性的作用"></a>13.Vue组件的scoped属性的作用</h2><h3 id="可以使当前的样式只作用在当前的模块，实现了样式的私有化。"><a href="#可以使当前的样式只作用在当前的模块，实现了样式的私有化。" class="headerlink" title="可以使当前的样式只作用在当前的模块，实现了样式的私有化。"></a>可以使当前的样式只作用在当前的模块，实现了样式的私有化。</h3><h2 id="14-Vue是渐进式的框架的理解"><a href="#14-Vue是渐进式的框架的理解" class="headerlink" title="14.Vue是渐进式的框架的理解"></a>14.Vue是渐进式的框架的理解</h2><h3 id="没有多做职责之外的事"><a href="#没有多做职责之外的事" class="headerlink" title="没有多做职责之外的事"></a>没有多做职责之外的事</h3><h2 id="15-Vue的两个核心是什么？"><a href="#15-Vue的两个核心是什么？" class="headerlink" title="15.Vue的两个核心是什么？"></a>15.Vue的两个核心是什么？</h2><h3 id="数据驱动：Object-defineProperty"><a href="#数据驱动：Object-defineProperty" class="headerlink" title="数据驱动：Object.defineProperty"></a>数据驱动：Object.defineProperty</h3><h3 id="存储器属性：getter和setter"><a href="#存储器属性：getter和setter" class="headerlink" title="存储器属性：getter和setter"></a>存储器属性：getter和setter</h3><h2 id="16-Vue常用修饰符"><a href="#16-Vue常用修饰符" class="headerlink" title="16.Vue常用修饰符"></a>16.Vue常用修饰符</h2><pre><code>+ v-model.lazy+ v-model.number+ v-model.trim+ .stop+ .self+ .once</code></pre><h2 id="17-v-on可以监听多个方法吗？"><a href="#17-v-on可以监听多个方法吗？" class="headerlink" title="17.v-on可以监听多个方法吗？"></a>17.v-on可以监听多个方法吗？</h2><h3 id="可以"><a href="#可以" class="headerlink" title="可以"></a>可以</h3><pre><code>+ v-on=&#39;{click: fn1,mouseenter: fn2}&#39;+ @click=&quot;fn1(),fn2()&quot;</code></pre><h2 id="18-Vue事件中如何使用event对象"><a href="#18-Vue事件中如何使用event对象" class="headerlink" title="18.Vue事件中如何使用event对象"></a>18.Vue事件中如何使用event对象</h2><pre><code>+ @click=&quot;fn($event)&quot;</code></pre><h2 id="19-比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0"><a href="#19-比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0" class="headerlink" title="19.比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0"></a>19.比如你想让一个dom元素显示，然后下一步去获取这个元素的offsetWidth，最后你获取到的会是0</h2><h3 id="因为你改变数据把show变成true-元素并不会立即显示，理所当然也不会获取到动态宽度。正确的做法是先把元素show出来，在-nextTick去执行获取宽度的操作，不知道这样说会不会好理解一点。"><a href="#因为你改变数据把show变成true-元素并不会立即显示，理所当然也不会获取到动态宽度。正确的做法是先把元素show出来，在-nextTick去执行获取宽度的操作，不知道这样说会不会好理解一点。" class="headerlink" title="因为你改变数据把show变成true,元素并不会立即显示，理所当然也不会获取到动态宽度。正确的做法是先把元素show出来，在$nextTick去执行获取宽度的操作，不知道这样说会不会好理解一点。"></a>因为你改变数据把show变成true,元素并不会立即显示，理所当然也不会获取到动态宽度。正确的做法是先把元素show出来，在$nextTick去执行获取宽度的操作，不知道这样说会不会好理解一点。</h3><pre><code>+ showDom() {    this.show = true;    this.$nextTick(() =&gt; {        //这里获取宽度    })}</code></pre><h2 id="20-Vue组件中data为什么必须是函数？"><a href="#20-Vue组件中data为什么必须是函数？" class="headerlink" title="20.Vue组件中data为什么必须是函数？"></a>20.Vue组件中data为什么必须是函数？</h2><h3 id="vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。"><a href="#vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。" class="headerlink" title="vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。"></a>vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响。</h3><h2 id="21-Vue中子组件调用父组件的方法"><a href="#21-Vue中子组件调用父组件的方法" class="headerlink" title="21.Vue中子组件调用父组件的方法"></a>21.Vue中子组件调用父组件的方法</h2><pre><code>+ this.$parent.fn+ 父组件传参，子组件使用props接受，然后再调用+ props: {    fn: {        type: Function,        default: null    }}</code></pre><h2 id="22-vue中keep-alive组件的作用"><a href="#22-vue中keep-alive组件的作用" class="headerlink" title="22.vue中keep-alive组件的作用"></a>22.vue中keep-alive组件的作用</h2><h3 id="keep-alive-可以使被包含的组件保留当前状态，避免重新渲染。"><a href="#keep-alive-可以使被包含的组件保留当前状态，避免重新渲染。" class="headerlink" title="keep-alive 可以使被包含的组件保留当前状态，避免重新渲染。"></a>keep-alive 可以使被包含的组件保留当前状态，避免重新渲染。</h3><pre><code>+ 路由部分  {      path: &#39;/test&#39;,      name: &#39;test&#39;,      component: test,      meta: {          keepAlive: true      }  }+ router-view 部分  &lt;keep-alive&gt;    //被缓存的    &lt;router-view v-if=&#39;$route.meta.keepAlive&#39;&gt;&lt;/router-view&gt;  &lt;/keep-alive&gt;    //不被缓存的    &lt;router-view v-if=&#39;!$route.meta.keepAlive&#39;&gt;&lt;/router-view&gt;</code></pre><h2 id="23-Vue中如何编写可复用的组件？"><a href="#23-Vue中如何编写可复用的组件？" class="headerlink" title="23.Vue中如何编写可复用的组件？"></a>23.Vue中如何编写可复用的组件？</h2><h2 id="24-什么是Vue生命周期和生命周期钩子函数"><a href="#24-什么是Vue生命周期和生命周期钩子函数" class="headerlink" title="24.什么是Vue生命周期和生命周期钩子函数"></a>24.什么是Vue生命周期和生命周期钩子函数</h2><h2 id="25-Vue更新数组时触发视图更新的方法"><a href="#25-Vue更新数组时触发视图更新的方法" class="headerlink" title="25.Vue更新数组时触发视图更新的方法"></a>25.Vue更新数组时触发视图更新的方法</h2><pre><code>+ this.$set方法</code></pre><h2 id="26-webpack编译原理"><a href="#26-webpack编译原理" class="headerlink" title="26.webpack编译原理"></a>26.webpack编译原理</h2><h2 id="27-Vue等单页面应用及其优缺点"><a href="#27-Vue等单页面应用及其优缺点" class="headerlink" title="27.Vue等单页面应用及其优缺点"></a>27.Vue等单页面应用及其优缺点</h2><pre><code>+ 缺点：    - 不支持低版本浏览器，只支持到IE9    - 不利于SEO优化    - 第一次加载时间较长+ 优点     - 无刷新，提升了用户体验    - 采用组件化思想，代码模块化，可以复用了</code></pre><h2 id="28-什么-是Vue的计算属性"><a href="#28-什么-是Vue的计算属性" class="headerlink" title="28.什么 是Vue的计算属性"></a>28.什么 是Vue的计算属性</h2><h3 id="监听一个或多个值，进行计算并且同步显示更改"><a href="#监听一个或多个值，进行计算并且同步显示更改" class="headerlink" title="监听一个或多个值，进行计算并且同步显示更改"></a>监听一个或多个值，进行计算并且同步显示更改</h3><pre><code>+ computed: {    newValue() {        return this.a+this.b    }}</code></pre><h2 id="29-vue-cli提供几种脚手架模版"><a href="#29-vue-cli提供几种脚手架模版" class="headerlink" title="29.vue-cli提供几种脚手架模版"></a>29.vue-cli提供几种脚手架模版</h2><h2 id="30-组件中传递数据"><a href="#30-组件中传递数据" class="headerlink" title="30.组件中传递数据"></a>30.组件中传递数据</h2><pre><code>+ props 父传子+ $emit 子传父   this.$emit(&#39;fn名&#39;,&#39;要传的参数&#39;);</code></pre><h2 id="31-vue-router实现路由懒加载"><a href="#31-vue-router实现路由懒加载" class="headerlink" title="31.vue-router实现路由懒加载"></a>31.vue-router实现路由懒加载</h2><pre><code>+ component: reslove =&gt; require([&#39;@/components/test&#39;],reslove)</code></pre><h2 id="32-vue-router的导航钩子，主要用来作用是拦截导航，让它完成跳转或取消"><a href="#32-vue-router的导航钩子，主要用来作用是拦截导航，让它完成跳转或取消" class="headerlink" title="32.vue-router的导航钩子，主要用来作用是拦截导航，让它完成跳转或取消"></a>32.vue-router的导航钩子，主要用来作用是拦截导航，让它完成跳转或取消</h2><h2 id="33-完整的vue-router导航解析流程"><a href="#33-完整的vue-router导航解析流程" class="headerlink" title="33.完整的vue-router导航解析流程"></a>33.完整的vue-router导航解析流程</h2><h2 id="34-vue-router如何响应-路由参数-的变化"><a href="#34-vue-router如何响应-路由参数-的变化" class="headerlink" title="34.vue-router如何响应 路由参数 的变化"></a>34.vue-router如何响应 路由参数 的变化</h2><pre><code>+ watch: {    &#39;$route&#39;(to,from) {        //做出变化    }}</code></pre><h2 id="35-vue-router的几种实例方法以及参数传递"><a href="#35-vue-router的几种实例方法以及参数传递" class="headerlink" title="35.vue-router的几种实例方法以及参数传递"></a>35.vue-router的几种实例方法以及参数传递</h2><pre><code>+ &lt;router-link to=&quot;test&quot;&gt;&lt;/router-link&gt;+ &lt;router-link :to=&quot;&#39;test&#39;&quot;&gt;&lt;/router-link&gt;+ &lt;router-link :to=&quot;{path: &#39;/test&#39;}&quot;&gt;&lt;/router-link&gt;+ &lt;router-link :to=&quot;{name: &#39;test&#39;}&quot;&gt;&lt;/router-link&gt;+ this.$router.push({path: &#39;/xxx&#39;, query: {a:1,b:2}})+ this.$router.push({name: &#39;xxx&#39;, params: {a:1,b:2}})</code></pre><h2 id="36-is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）"><a href="#36-is的用法（用于动态组件且基于-DOM-内模板的限制来工作。）" class="headerlink" title="36.is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）"></a>36.is的用法（用于动态组件且基于 DOM 内模板的限制来工作。）</h2><h2 id="37-vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#37-vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="37.vuex是什么？怎么使用？哪种功能场景使用它？"></a>37.vuex是什么？怎么使用？哪种功能场景使用它？</h2><h3 id="状态管理：state、getter、mutation、action、moudule"><a href="#状态管理：state、getter、mutation、action、moudule" class="headerlink" title="状态管理：state、getter、mutation、action、moudule"></a>状态管理：state、getter、mutation、action、moudule</h3><pre><code>+ state 存放数据+ getter 获取数据+ mutation 写方法的地方，他是同步事件，使用store.commit()调用+ action 写方法的地方，是异步事件，使用store.dispatch()调用</code></pre>]]></content>
    
    <summary type="html">
    
      面试题整理
    
    </summary>
    
      <category term="前端" scheme="https://LittleChai.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="面试" scheme="https://LittleChai.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题合集</title>
    <link href="https://LittleChai.github.io/2020/05/10/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <id>https://LittleChai.github.io/2020/05/10/面试题合集/</id>
    <published>2020-05-10T13:20:00.000Z</published>
    <updated>2020-05-28T03:54:51.240Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/f1f39d5b2a2e" target="_blank" rel="noopener">‘面试题合集’</a></p><h2 id="题目顺序不分先后"><a href="#题目顺序不分先后" class="headerlink" title="题目顺序不分先后"></a>题目顺序不分先后</h2><h3 id="小程序传参的三种方法"><a href="#小程序传参的三种方法" class="headerlink" title="小程序传参的三种方法"></a>小程序传参的三种方法</h3><ul><li>跳转地址后直接加参数   例如：?id=1</li><li>使用系统缓存 wx.setStorageSync</li><li>使用app.js中的globalData对象  var app = getApp();  app.globalData.xxx</li></ul><h3 id="数组去重有哪些方法"><a href="#数组去重有哪些方法" class="headerlink" title="数组去重有哪些方法"></a>数组去重有哪些方法</h3><ul><li>arr.filter<pre><code class="js">let arr = [111,111,222,333,444,555,555];let arr2 = arr.filter((item,index) =&gt; {return arr.indexOf(item) === index})console.log(arr2); // [111,222,333,444,555]</code></pre></li><li>new Set([111,111,222,333,444,555,555])<pre><code class="js">let arr = [111,111,222,333,444,555,555];let arr2 = Array.from(new Set([...arr]))console.log(arr2) // [111,222,333,444,555]</code></pre></li><li><p>for循环算法</p><pre><code class="js">let arr = [111,111,222,333,444,555,555];function distinct(arr) {  for (let i=0, len=arr.length; i&lt;len; i++) {      for (let j=i+1; j&lt;len; j++) {          if (arr[i] == arr[j]) {              arr.splice(j, 1);              // splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一              len--;              j--;          }      }  }  return arr}console.log(distinct(arr))  // [111,222,333,444,555]</code></pre></li><li>includes()方法<pre><code class="js">let result = []for (let i of arr) {!result.includes(i) &amp;&amp; result.push(i)}console.log(result)  // [111,222,333,444,555]</code></pre></li><li><p>arr.reduce</p><pre><code class="js">let arr1 = [111,111,222,333,444,555,555];let arr2 = arr1.reduce((prev,cur,index) =&gt; {prev.includes(cur) ? &#39;&#39; : prev.push(cur)return prev},[])console.log(arr2)</code></pre></li></ul><h3 id="父组件给子组件传值"><a href="#父组件给子组件传值" class="headerlink" title="父组件给子组件传值"></a>父组件给子组件传值</h3><pre><code class="js">// 父组件&lt;child :val1=&#39;fatherVal1&#39; :val2=&#39;fatherVal2&#39; &gt;&lt;child&gt;data() {  return {    fatherVal1: &#39;我是父组件的值&#39;,    fatherVal2: {                &#39;aa&#39;: 1,                &#39;cc&#39;: 2            },  }}// 子组件export default {  props: {    val1: {      type: &#39;string&#39;,      default: () =&gt; {        return &quot;&quot;      }    },    val2: {      type: &#39;object&#39;,      default: ()=&gt; {        return &quot;&quot;      }    }  }}</code></pre><h3 id="子组件给父组件传值"><a href="#子组件给父组件传值" class="headerlink" title="子组件给父组件传值"></a>子组件给父组件传值</h3><pre><code class="js">// 子组件&lt;button @click=&#39;toFather&#39;&gt;&lt;/button&gt;methods: {  toFather() {    this.$emit(&#39;fromChild&#39;,&#39;我是子组件传过来的&#39;)  }}// 父组件&lt;child @fromChild=&#39;fn&#39;&gt;&lt;/child&gt;methods: {  fn(msg) {    console.log(msg) //我是子组件传过来的  }}</code></pre><h3 id="彻底搞懂vuex"><a href="#彻底搞懂vuex" class="headerlink" title="彻底搞懂vuex"></a>彻底搞懂vuex</h3><pre><code class="js">// state.jsconst state = {    num: 1,    type: &#39;one&#39;}   export default state// mutations.jsimport state from &#39;./state&#39;;const mutations = {    changeNum(state,n) {        state.num = n;    },    changeType(state,n) {        state.type = n;    }}export default mutations// getters.jsconst getters = {    getNum(state) {        return state.num    },    getType(state) {        return state.type    }}// actions.jsimport state from &#39;./state&#39;const actions = {  changeNum(content,val) {    return new Promise((resolve) =&gt; {      // 模拟异步      setTimeout(() =&gt; {        content.commit(&#39;changeNum&#39;,val)        resolve();      },3000)    })  }}// index.jsimport Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import state from &#39;./state&#39;import getters from &#39;./getters&#39;import mutations from &#39;./mutations&#39;import actions from &#39;./actions&#39;Vue.use(Vuex)const store = new Vuex.Store({    state,    getters,    mutations,    actions})export default store</code></pre><h3 id="flex-排列元素自适应"><a href="#flex-排列元素自适应" class="headerlink" title="flex 排列元素自适应"></a>flex 排列元素自适应</h3><pre><code class="html">&lt;div class=&quot;test_flex&quot;&gt;  &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;flex_child&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.test_flex {  width: 100%;  height: 200px;  background-color: gray;  display: flex;  flex-flow: row nowrap;}.flex_child {  flex: 1;  margin: 10px 0 10px 10px;  max-width: 20%;  background-color: goldenrod;}.flex_child:last-child {  margin-right: 10px;}&lt;/style&gt;</code></pre><h3 id="vue路由传参"><a href="#vue路由传参" class="headerlink" title="vue路由传参"></a>vue路由传参</h3><pre><code class="js">this.$router.push({  name: &#39;a&#39;,  params: {    val: &#39;参数&#39;  }})// 浏览器地址栏看不到参数// this.$route.params获取this.$router.push({  path: &#39;/a&#39;,  query: {    val: &#39;参数&#39;  }})// 浏览器地址栏可以看到参数// this.$route.query获取</code></pre><h3 id="view-design按需加载"><a href="#view-design按需加载" class="headerlink" title="view-design按需加载"></a>view-design按需加载</h3><pre><code class="js">npm install babel-plugin-import --save-dev根目录新建.babelrc文件// .babelrc{  &quot;plugins&quot;: [[&quot;import&quot;, {    &quot;libraryName&quot;: &quot;view-design&quot;,    &quot;libraryDirectory&quot;: &quot;src/components&quot;  }]]}//main.js引入import { Button, Table } from &#39;view-design&#39;;import &#39;view-design/dist/styles/iview.css&#39;;Vue.component(&#39;Button&#39;, Button);Vue.component(&#39;Table&#39;, Table);</code></pre><h3 id="浏览器缓存解决"><a href="#浏览器缓存解决" class="headerlink" title="浏览器缓存解决"></a>浏览器缓存解决</h3><ul><li>给文件改名</li></ul><h3 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h3><ul><li>proxy  </li><li>jsonp</li><li>后端cors</li></ul><h3 id="es5声明变量的方法"><a href="#es5声明变量的方法" class="headerlink" title="es5声明变量的方法"></a>es5声明变量的方法</h3><ul><li>var</li></ul><h3 id="es6声明变量的方法"><a href="#es6声明变量的方法" class="headerlink" title="es6声明变量的方法"></a>es6声明变量的方法</h3><ul><li>let </li><li>const  </li><li>function</li><li>class</li><li>import</li></ul><h3 id="mvvm是什么"><a href="#mvvm是什么" class="headerlink" title="mvvm是什么"></a>mvvm是什么</h3><ul><li>Model-View-ViewModel的简写</li><li>Model：代表数据模型，数据和业务逻辑都在Model层中定义</li><li>View：代表UI视图，负责数据的展示</li><li>ViewModel：负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作</li></ul><h3 id="mvvm对开发者有什么好处"><a href="#mvvm对开发者有什么好处" class="headerlink" title="mvvm对开发者有什么好处"></a>mvvm对开发者有什么好处</h3><ul><li>低耦合。</li><li>视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li>可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li><li>独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li>可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li><li>易用灵活高效</li></ul><h3 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h3><ul><li>也就是说， v-model=”sth” 是 v-bind:value=”sth” @input=”sth = $event.target.value” 的缩写。</li></ul><h3 id="es6哪些新特性"><a href="#es6哪些新特性" class="headerlink" title="es6哪些新特性"></a>es6哪些新特性</h3><ul><li>字符串模版</li><li>解构</li><li>对象字面量写法</li><li>箭头函数</li><li>字符串查找 inCludes</li><li>promise</li><li>class</li><li>set</li></ul><h3 id="es7新特新"><a href="#es7新特新" class="headerlink" title="es7新特新"></a>es7新特新</h3><ul><li>3 ** 2 求幂运算符</li></ul><h3 id="es8新特新"><a href="#es8新特新" class="headerlink" title="es8新特新"></a>es8新特新</h3><ul><li>padStart padEnd 前后补充指定字符串  </li><li>‘aabbc’.padStart(6,’x’);  //xaabbc</li><li>Object.entries</li><li>Object.values</li><li>async await</li></ul><h3 id="数组有哪些操作方法"><a href="#数组有哪些操作方法" class="headerlink" title="数组有哪些操作方法"></a>数组有哪些操作方法</h3><ul><li>push 后添加</li><li>pop 后删除 </li><li>unshift 开头</li><li>shift 开头删除</li><li>splice(index,1,xx) 替换或删除数组，改变原数组 </li><li>slice(start,end) 截取数组，不改变原数组</li><li>concat 数组拼接</li><li>foreach遍历</li><li>arr.reduce</li><li>arr.map</li><li>arr.filter 数组过滤</li><li>arr.sort 排序</li><li>arr.some</li></ul><h3 id="如何优化性能"><a href="#如何优化性能" class="headerlink" title="如何优化性能"></a>如何优化性能</h3><ul><li>资源压缩合并，减少http请求</li><li>异步加载</li><li>添加浏览器缓存</li><li>使用cdn</li></ul><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><ul><li>beforeCreate</li><li>created</li><li>beforeMount</li><li>mounted</li><li>beforeUpdate</li><li>updated</li><li>beforeDestory</li><li>destoryed</li></ul><h3 id="router-beforeEach"><a href="#router-beforeEach" class="headerlink" title="router  beforeEach"></a>router  beforeEach</h3><ul><li>监听路由，可以进行拦截重定向等操作</li></ul><h3 id="小程序跳转方式"><a href="#小程序跳转方式" class="headerlink" title="小程序跳转方式"></a>小程序跳转方式</h3><ul><li>navigateTo</li><li>redirectTo</li><li>relaunch</li><li>navigateBack</li><li>switchTab</li></ul><h3 id="小程序生命周期"><a href="#小程序生命周期" class="headerlink" title="小程序生命周期"></a>小程序生命周期</h3><p>  1、进入A页面：A执行onLoad()–&gt;onShow()–&gt;onReady()；<br>  2、A页面navigateTo B页面：A执行onHide()，B执行onLoad()–&gt;onShow()–&gt;onReady()；<br>  3、B页面返回A页面：B执行onUnload()，A执行onShow()；<br>  4、退出A页面：A执行onUnload()。</p><h3 id="v-if-v-show区别"><a href="#v-if-v-show区别" class="headerlink" title="v-if v-show区别"></a>v-if v-show区别</h3><ul><li>v-if按照条件是否渲染，v-show是display的block或none</li></ul><h3 id="vue几种常见指令"><a href="#vue几种常见指令" class="headerlink" title="vue几种常见指令"></a>vue几种常见指令</h3><ul><li>v-for 、 v-if 、v-bind、v-on、v-show、v-else、v-model、v-html</li></ul><h3 id="es8新特性"><a href="#es8新特性" class="headerlink" title="es8新特性"></a>es8新特性</h3><ul><li>async await</li><li>padStart padEnd</li><li>Object.entries() 把对象或字符串转成数组</li><li>Object.values()</li></ul><h3 id="vue跨域解决"><a href="#vue跨域解决" class="headerlink" title="vue跨域解决"></a>vue跨域解决</h3><pre><code class="js">module.exports = {    // 是否使用带有浏览器内核编译器的完整构建版本    runtimeCompiler: false,    // 基本路径    publicPath: &#39;./&#39;,    //map文件    productionSourceMap: false,    // 构建时的输出目录    outputDir: &#39;dist&#39;,    //放置静态资源的目录    assetsDir: &#39;static&#39;,    //html的输出路径    indexPath: &#39;index.html&#39;,    // 文件名哈希值    filenameHashing: true,    devServer: {        host: &#39;192.168.1.108&#39;,        port: 8088,        https: false,        // 自启动浏览器        open: false,        // 跨域        proxy: {            &#39;/api&#39;: {                target: &#39;http://v.juhe.cn&#39;,                changeOrigin: true,                ws: true,                secure: false,                pathRewrite: {                    &#39;^/api&#39;: &#39;&#39;                },                disableHostCheck: true            }        }    },    // 清除console.log    configureWebpack: (config) =&gt; {        if (process.env.NODE_ENV === &#39;production&#39;) {            config.optimization.minimizer[0].options.terserOptions.compress.drop_console = true        }    }}</code></pre><h3 id="reduce操作方法"><a href="#reduce操作方法" class="headerlink" title="reduce操作方法"></a>reduce操作方法</h3><pre><code class="js">// arr 表示原数组；// prev 表示上一次调用回调时的返回值，或者初始值 init;// cur 表示当前正在处理的数组元素；// index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；// init 表示初始值。var sum = arr.reduce((prev, cur) =&gt; {    return prev + cur;},0);// 重复次数计算let names = [&#39;AAA&#39;, &#39;BBB&#39;, &#39;CCC&#39;, &#39;DDD&#39;, &#39;AAA&#39;];let nameNum = names.reduce((pre, cur) =&gt; {cur in pre ? pre[cur] += 1 : pre[cur] = 1  return pre}, {})console.log(nameNum); // {AAA: 2, BBB: 1, CCC: 1, DDD: 1}//数组去重let names = [&#39;AAA&#39;, &#39;BBB&#39;, &#39;CCC&#39;, &#39;DDD&#39;, &#39;AAA&#39;];let nameNum1 = names.reduce((pre, cur, index) =&gt; {pre.includes(cur) ? &#39;&#39; : pre.push(cur)  return pre}, [])console.log(nameNum1);  // [&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;, &quot;DDD&quot;]//数组对象去重，转为数组const names2 = [      { name: &#39;AAA&#39; },      { name: &#39;BBB&#39; },      { name: &#39;DDD&#39; },      { name: &#39;CCC&#39; },      { name: &#39;EEE&#39; },      { name: &#39;AAA&#39; },    ];      let nameNum2 = names2.reduce((pre, cur, index) =&gt; {      pre.includes(cur.name) ? &#39;&#39; : pre.push(cur.name)      return pre    }, [])    console.log(nameNum2);  //  [&quot;AAA&quot;, &quot;BBB&quot;, &quot;DDD&quot;, &quot;CCC&quot;, &quot;EEE&quot;]//对象去重 const names2 = [     { name: &#39;AAA&#39; },     { name: &#39;BBB&#39; },     { name: &#39;DDD&#39; },     { name: &#39;CCC&#39; },     { name: &#39;EEE&#39; },     { name: &#39;AAA&#39; },   ]   let obj = {}   let nameNum3 = names2.reduce((pre, cur) =&gt; {     obj[cur.name] ? &#39;&#39; : obj[cur.name] = true &amp;&amp; pre.push(cur)     return pre    }, [])    console.log(nameNum3);  // [{ name: &#39;AAA&#39; },{ name: &#39;BBB&#39; },{ name: &#39;DDD&#39; },{ name: &#39;CCC&#39; },{ name: &#39;EEE&#39; }]</code></pre><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>200</li><li>404</li><li>502 网关错误</li><li>500 服务器内部错误</li><li>504 请求超时</li></ul><h3 id="vue双向数据绑定的原理是什么"><a href="#vue双向数据绑定的原理是什么" class="headerlink" title="vue双向数据绑定的原理是什么"></a>vue双向数据绑定的原理是什么</h3><p>首先传输对象的双向数据绑定 Object.defineProperty(target, key, decription),在decription中设置get和set属性（此时应注意description中get和set不能与描述属性共存）<br>数组的实现与对象不同。<br>同时运用观察者模式实现wather，用户数据和view视图的更新</p><h3 id="闭包的好处"><a href="#闭包的好处" class="headerlink" title="闭包的好处"></a>闭包的好处</h3><ul><li>(1)希望一个变量长期驻扎在内存当中(不被垃圾回收机制回收)</li><li>(2)避免全局变量的污染</li><li>(3)私有成员的存在</li><li>(4)安全性提高</li></ul>]]></content>
    
    <summary type="html">
    
      最近面试遇到的一些问题
    
    </summary>
    
      <category term="面试" scheme="https://LittleChai.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端" scheme="https://LittleChai.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="https://LittleChai.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="技术" scheme="https://LittleChai.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>ES6,ES7,ES8常用新特性</title>
    <link href="https://LittleChai.github.io/2020/03/12/ES6,ES7,ES8%E5%B8%B8%E7%94%A8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://LittleChai.github.io/2020/03/12/ES6,ES7,ES8常用新特性/</id>
    <published>2020-03-12T10:55:30.000Z</published>
    <updated>2020-03-12T10:55:25.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES6特性"><a href="#ES6特性" class="headerlink" title="ES6特性"></a>ES6特性</h2><h3 id="const-let变量"><a href="#const-let变量" class="headerlink" title="const,let变量"></a>const,let变量</h3><p><strong>关于使用let与const规则:</strong></p><ul><li>使用let声明的变量可以重新赋值,但是不能在同一作用域内重新声明</li><li>使用const声明的变量必须赋值初始化,但是不能在同一作用域类重新声明也无法重新赋值</li></ul><pre><code class="JavaScript">let a = 1;const b = 2;</code></pre><h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><p><strong>在ES6之前,将字符串连接到一起的方法是+或者concat()方法</strong><br><strong>而现在可以使用 `` 语法</strong></p><pre><code class="JavaScript">//之前let name = &#39;tom&#39;;let age = 12;let str = name+&#39; is &#39;+age+&#39; years old&#39;;//现在let name = &#39;tom&#39;;let age = 12;let str = `${name} is ${age} years old`;</code></pre><h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p><strong>在ES6中,可以使用解构从数组和对象提取值并赋值给独特的变量</strong><br><strong>解构数组</strong></p><pre><code class="JavaScript">let arr = [12,23,34];let [a,b,c] = arr;console.log(a,b,c); //12,23,34let [a,[b,c],d] = [1,[2,3],4];// 解构赋值默认值let [bol = true] = [] //true// 字符串解构赋值let [a,b,c,d,e,f,g] = &#39;qwertyu&#39;;</code></pre><p><strong>[]表示被解构的数组, a,b,c表示要将数组中的值存储在其中的变量, 在解构数组是, 还可以忽略值, 例如const[a,,c]=arr,忽略b坐标.</strong></p><p><strong>解构对象</strong></p><pre><code class="JavaScript">let obj = {  name: &#39;tom&#39;,  age: 20,  sex: &#39;男&#39;};let {name,age,sex} = obj;console.log(name,age,sex); //tom,20,男</code></pre><p><strong>花括号 { } 表示被解构的对象，name、age 和 sex 表示要将对象中的属性存储到其中的变量</strong></p><h3 id="对象字面量简写法"><a href="#对象字面量简写法" class="headerlink" title="对象字面量简写法"></a>对象字面量简写法</h3><pre><code class="JavaScript">let name = &#39;tom&#39;;let age = 12;let sex = &#39;男&#39;;let people = {  name: name,  age: age,  sex: sex};console.log(people);/*{  age: 12  name: &quot;tom&quot;  sex: &quot;男&quot;  }*/</code></pre><p><strong>使用和所分配的变量名称相同的名称初始化对象时</strong><br><strong>如果属性名称和所分配的变量名称一样，那么就可以从对象属性中删掉这些重复的变量名称。</strong></p><pre><code class="JavaScript">let name = &#39;tom&#39;;let age = 12;let sex = &#39;男&#39;;let people = {name,age,sex};console.log(people)/*{  age: 12  name: &quot;tom&quot;  sex: &quot;男&quot;  }*/</code></pre><p><strong>简写方法的名称:</strong></p><pre><code class="JavaScript">let gemstone = {  name,  age,  sex,  fn() { ... }};</code></pre><h3 id="ES6箭头函数"><a href="#ES6箭头函数" class="headerlink" title="ES6箭头函数"></a>ES6箭头函数</h3><pre><code class="JavaScript">let fn = (a,b) =&gt; {  console.log(a,b)}fn(1,2);</code></pre><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><pre><code class="JavaScript">let str = &#39;sky&#39;;let strs = &#39;I see a bird in the sky&#39;;strs.inCludes(str) //true//判断开头是否存在strs.startsWith(str)//判断结尾是否存在strs.endsWith(str)//复制字符串str.repeat(2) //skysky</code></pre><h3 id="数字验证"><a href="#数字验证" class="headerlink" title="数字验证"></a>数字验证</h3><pre><code class="JavaScript">//验证是否是数字，整数，小数都可以Number.isFinite(12) //trueNumber.isFinite(12.12) //true//NaN验证Number.isNaN(NaN) //true//判断是否为整数Number.isInteger(12.12) //false//整数转换Number.parseInt(12.12) //12//浮点数转换Number.parseFloat(12)</code></pre><h3 id="JSON数组格式转换"><a href="#JSON数组格式转换" class="headerlink" title="JSON数组格式转换"></a>JSON数组格式转换</h3><pre><code class="JavaScript">let  json = {    &#39;0&#39;: &#39;one&#39;,    &#39;1&#39;: &#39;two&#39;,    &#39;2&#39;: &#39;three&#39;,    length:3}let arr = Array.from(json) //[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]let arr =Array.of(3,4,5,6);console.log(arr);//[3,4,5,6]//fill填充let arr = [1,2,3,4,5];arr.fill(&#39;add&#39;,2,5);// 3,4,5被填充覆盖//[1, 2, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]//for...of循环let arr = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;];for(let item of arr) {  console.log(item)  //one  //two  //three}// 或得索引和元素let arr = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;];for(let [index,item] of arr.entries()) {  console.log(index,item)  //0,one  //1,two  //2,three}</code></pre><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><pre><code class="JavaScript">if(true) {  throw new Error(&#39;出错了&#39;)}</code></pre><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><pre><code class="JavaScript">let arr = [&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;,&#39;five&#39;]//forEach//forEach循环的特点是会自动省略为空的数组元素，相当于直接给我们筛空了。当是有时候也会给我们帮倒忙。arr.forEach((item,index) =&gt; {  console.log(item,index)})//filter 筛选let arr2 = arr.filter((item,index) =&gt; {  if(item != &#39;three&#39;) {    return true;  }})// [&#39;one&#39;,&#39;two&#39;,&#39;four&#39;,&#39;five&#39;]//somearr.some((item,index) =&gt; {  console.log(item,index)})//maparr.map(x=&gt;&#39;a&#39;)</code></pre><h3 id="对象比较Object-is"><a href="#对象比较Object-is" class="headerlink" title="对象比较Object.is()"></a>对象比较Object.is()</h3><pre><code class="JavaScript">let obj1 = {  name: &#39;啦啦啦&#39;}let obj2 = {  name: &#39;啦啦啦&#39;}Object.is(obj1.name,obj2.name); //trueconsole.log(+0 === -0);  //trueconsole.log(NaN === NaN ); //falseconsole.log(Object.is(+0,-0)); //falseconsole.log(Object.is(NaN,NaN)); //true</code></pre><h3 id="对象合并Object-assign"><a href="#对象合并Object-assign" class="headerlink" title="对象合并Object.assign()"></a>对象合并Object.assign()</h3><pre><code class="JavaScript">let obj1 = {  a: &#39;a1&#39;}let obj2 = {  b: &#39;b1&#39;}let obj3 = {  c: &#39;c1&#39;}let obj4 = Object.assign(obj1,obj2,obj3) //{a: &quot;a1&quot;, b: &quot;b1&quot;, c: &quot;c1&quot;}</code></pre><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><pre><code class="JavaScript">let setArr = new Set([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;])//Set(3) {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}//会直接去重// 追加add// 删除delete// 查找has// 清空clear</code></pre><h3 id="map"><a href="#map" class="headerlink" title="map***"></a>map***</h3><pre><code class="JavaScript">let json = {  name: &#39;lalala&#39;,  skill: &#39;web&#39;}console.log(json)var map = new Map();map.set(json,&#39;am&#39;);console.log(map);map.set(&#39;heihei&#39;,json);console.log(map);//增删查//getconsole.log(map.get(json))  //amconsole.log(map.get(&#39;heihei&#39;))  //json//delete删除特定map.delete(json);//删除全部map.clear();//size 返回数量map.size; //2//has查找，返回true,falsemap.has(&#39;heihei&#39;)  //true// set(),get(),delete(),clear(),size,has()</code></pre><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><pre><code class="JavaScript">let state = 1;function step1(resolve,reject) {  console.log(&#39;第一步&#39;)  if(state == 1) {    resolve(&#39;ok&#39;)  }  else {    reject(&#39;no&#39;)  }}function step2(resolve,reject) {  console.log(&#39;第二步&#39;)  if(state == 1) {    resolve(&#39;ok&#39;)  }  else {    reject(&#39;no&#39;)  }}function step3(resolve,reject) {  console.log(&#39;第三步&#39;)  if(state == 1) {    resolve(&#39;ok&#39;)  }  else {    reject(&#39;no&#39;)  }}new Promise(step1).then(function(val){  console.log(val)  return new Promise(step2);}).then(function(val){  console.log(val)  return new Promise(step3);}).then(function(val){  console.log(val)})</code></pre><h3 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h3><pre><code class="JavaScript">class Coder{  constructor(a,b) {    this.a = a;    this.b = b;  }  name(val) {    console.log(val);    return val;  }  skill(val) {    console.log(this.name(&#39;god&#39;),val)  }  add() {    return this.a+this.b;  }}let littlechai = new Coder(&#39;aa&#39;,&#39;bb&#39;);littlechai.name(&#39;god&#39;);littlechai.skill(&#39;god&#39;);littlechai.add();// 继承class Htmler extends Coder{}let jicheng = new Htmler;jicheng.name(&#39;haha&#39;)</code></pre><h2 id="ES7特性"><a href="#ES7特性" class="headerlink" title="ES7特性"></a>ES7特性</h2><h3 id="Array-prototype-includes-方法"><a href="#Array-prototype-includes-方法" class="headerlink" title="Array.prototype.includes()方法"></a>Array.prototype.includes()方法</h3><p><strong>includes()方法用来判断一个数组是否包含一个指定的值,根据情况,如果包含则返回true,否则返回false</strong><br><strong>Array.prototype.includes()方法接收两个参数：</strong></p><ul><li>要搜索的值</li><li>搜索的开始索引</li></ul><pre><code class="JavaScript">var arr = [1,3,5,7,9,11,13];console.log(arr.includes(2));  //falseconsole.log(arr.includes(7));  //truevar pets = [&#39;dog&#39;,&#39;cat&#39;,&#39;bird&#39;];console.log(pets.includes(&#39;cat&#39;));  //trueconsole.log(pets.includes(&#39;ca&#39;));  //false</code></pre><p><strong>当第二个参数被传入时，该方法会从索引处开始往后搜索（默认索引值为0）。若搜索值在数组中存在则返回true，否则返回false。 且看下面示例：</strong></p><pre><code class="JavaScript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;].includes(&#39;b&#39;)         // true[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;].includes(&#39;b&#39;, 1)      // true[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;].includes(&#39;b&#39;, 2)      // false</code></pre><p><strong>NaN的判断。如果数组中有NaN，你又正好需要判断数组是否有存在NaN，这时你使用indexOf是无法判断的，你必须使用includes这个方法。</strong></p><pre><code class="JavaScript">var ary1 = [NaN];console.log(ary1.indexOf(NaN))//-1console.log(ary1.includes(NaN))//true</code></pre><p><strong>当数组的有空的值的时候，includes会认为空的值是undefined，而indexOf不会。</strong></p><pre><code class="JavaScript">var ary1 = new Array(3);console.log(ary1.indexOf(undefined));//-1console.log(ary1.includes(undefined))//true</code></pre><p><br></p><h3 id="求幂运算符"><a href="#求幂运算符" class="headerlink" title="求幂运算符(**)"></a>求幂运算符(**)</h3><p><strong>通常求幂运算是用Math.pow()方法,但现在可以使用**</strong></p><pre><code class="JavaScript">3 ** 5  //243Math.pow(3,5)  //243//还支持以下操作let n = 3;n **= 5; //243</code></pre><h2 id="ES8特性"><a href="#ES8特性" class="headerlink" title="ES8特性"></a>ES8特性</h2><h3 id="Async-Functions"><a href="#Async-Functions" class="headerlink" title="Async Functions"></a>Async Functions</h3><p><strong>Async Functions也就是我们常说的Async/Await，Async/Await是一种用于处理JS异步操作的语法糖，可以帮助我们摆脱回调地狱，编写更加优雅的代码。</strong><br><strong>通俗的理解，async关键字的作用是告诉编译器对于标定的函数要区别对待。当编译器遇到标定的函数中的await关键字时，要暂时停止运行，带到await标定的函数处理完毕后，再进行相应操作。</strong><br><strong>用普通promise写法来做对比：</strong></p><pre><code class="JavaScript">async function asyncFunc() {    const result = await fn();    console.log(result);}function asyncFunc() {    return fn()    .then(result =&gt; {        console.log(result);    });}</code></pre><p><strong>按顺序处理</strong></p><pre><code class="JavaScript">async function asyncFunc() {    const result1 = await fn1();    console.log(result1);    const result2 = await fn2();    console.log(result2);}function asyncFunc() {    return fn1()    .then(result1 =&gt; {        console.log(result1);        return fn2();    })    .then(result2 =&gt; {        console.log(result2);    });}</code></pre><p><strong>并行处理多个异步函数</strong></p><pre><code class="JavaScript">async function asyncFunc() {    const [result1, result2] = await Promise.all([        fn1(),        fn2(),    ]);    console.log(result1, result2);}function asyncFunc() {    return Promise.all([        fn1(),        fn2(),    ])    .then([result1, result2] =&gt; {        console.log(result1, result2);    });}</code></pre><p><strong>错误处理</strong></p><pre><code class="JavaScript">async function asyncFunc() {    try {        await fn();    } catch (err) {        console.error(err);    }}function asyncFunc() {    return fn()    .catch(err =&gt; {        console.error(err);    });}</code></pre><h3 id="Object-values-and-Object-entries"><a href="#Object-values-and-Object-entries" class="headerlink" title="Object.values and Object.entries"></a>Object.values and Object.entries</h3><p><strong>Object.values() 方法返回一个给定对象自己的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于for-in循环枚举原型链中的属性 )。</strong><br><strong>obj参数是需要待操作的对象。可以是一个对象，或者一个数组（是一个带有数字下标的对象，[10,20,30] -&gt; {0: 10,1: 20,2: 30})。</strong></p><pre><code class="JavaScript">let obj = {  x: &#39;aaa&#39;,  y: 1};Object.values(obj); //[&#39;aaa&#39;,1]let obj = [&#39;e&#39;,&#39;s&#39;,&#39;8&#39;] //相当于 {0:&#39;e&#39;,1:&#39;s&#39;,2:&#39;8&#39;};Object.values(obj); //[&#39;e&#39;,&#39;s&#39;,&#39;8&#39;]// 当我们使用数字键值时，返回的是数字排序// 根据键值排序let obj = {  10: &#39;ccc&#39;,  3: &#39;ddd&#39;,  1: &#39;aaa&#39;}Object.values(obj) //[&#39;aaa&#39;,&#39;ddd&#39;,&#39;ccc&#39;]Object.values(&#39;es8&#39;); // [&#39;e&#39;, &#39;s&#39;, &#39;8&#39;]</code></pre><p><strong>Object.entries 方法返回一个给定对象自身可遍历属性 [key, value] 的数组， 排序规则和 Object.values 一样。这个方法的声明比较琐碎:</strong></p><pre><code class="JavaScript">let obj = {a: &#39;aaa&#39;, b: 2}Object.entries(obj)  //[[&#39;a&#39;,&#39;aaa&#39;],[&#39;b&#39;,2]]let obj = [&#39;e&#39;,&#39;s&#39;,&#39;8&#39;]Object.entries(obj) //[[&#39;0&#39;,&#39;e&#39;],[&#39;1&#39;,&#39;s&#39;],[&#39;2&#39;,&#39;8&#39;]]let obj = { 10: &#39;xxx&#39;, 1: &#39;yyy&#39;, 3: &#39;zzz&#39; };Object.entries(obj); // [[&#39;1&#39;, &#39;yyy&#39;], [&#39;3&#39;, &#39;zzz&#39;], [&#39;10&#39;: &#39;xxx&#39;]]Object.entries(&#39;es8&#39;); // [[&#39;0&#39;, &#39;e&#39;], [&#39;1&#39;, &#39;s&#39;], [&#39;2&#39;, &#39;8&#39;]]</code></pre><h3 id="String-padding"><a href="#String-padding" class="headerlink" title="String padding"></a>String padding</h3><p><strong>为String对象增加了两个函数: padStart和padEnd</strong><br><strong>像它们名字那样，这几个函数的主要目的就是填补字符串的首部和尾部，为了使得到的结果字符串的长度能达到给定的长度。你可以通过特定的字符，或者字符串，或者默认的空格填充它。下面是函数的声明：</strong></p><pre><code class="JavaScript">str.padStart(targetLength,空格||padString)str.padEnd(targetLength,空格||padString)</code></pre><p><strong>这些函数的第一个参数是 targetLength（目标长度），这个是结果字符串的长度。第二个参数是可选的 padString（填充字符），一个用于填充到源字符串的字符串。默认值是空格。</strong></p><pre><code class="JavaScript">&#39;es8&#39;.padStart(2);          // &#39;es8&#39;&#39;es8&#39;.padStart(5);          // &#39;  es8&#39;&#39;es8&#39;.padStart(6, &#39;woof&#39;);  // &#39;wooes8&#39;&#39;es8&#39;.padStart(14, &#39;wow&#39;);  // &#39;wowwowwowwoes8&#39;&#39;es8&#39;.padStart(7, &#39;0&#39;);     // &#39;0000es8&#39;&#39;es8&#39;.padEnd(2);            // &#39;es8&#39;&#39;es8&#39;.padEnd(5);            // &#39;es8  &#39;&#39;es8&#39;.padEnd(6, &#39;woof&#39;);    // &#39;es8woo&#39;&#39;es8&#39;.padEnd(14, &#39;wow&#39;);    // &#39;es8wowwowwowwo&#39;&#39;es8&#39;.padEnd(7, &#39;6&#39;);       // &#39;es86666&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      记录下一些新的语法特性,以免自己遗忘
    
    </summary>
    
      <category term="技术" scheme="https://LittleChai.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://LittleChai.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="https://LittleChai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>H5踩坑记录</title>
    <link href="https://LittleChai.github.io/2019/11/04/H5%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://LittleChai.github.io/2019/11/04/H5踩坑记录/</id>
    <published>2019-11-04T08:10:00.000Z</published>
    <updated>2019-11-04T08:51:27.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IOS端position-fixed、input同时使用的问题"><a href="#IOS端position-fixed、input同时使用的问题" class="headerlink" title="IOS端position:fixed、input同时使用的问题"></a>IOS端position:fixed、input同时使用的问题</h3><ul><li>IOS端下使用fixed定位时，如果页面存在input输入框，在输入完成以后会导致键盘占用页面的位置(虽然看起来键盘已经缩回去，但是实际上还是会存在于页面中，引起页面无法点击的bug，起初我还以为是代码逻辑问题。)</li><li>解决方法：使用absolute或者relative定位</li></ul><p><br></p><h3 id="ios端页面滚动不顺畅的问题"><a href="#ios端页面滚动不顺畅的问题" class="headerlink" title="ios端页面滚动不顺畅的问题"></a>ios端页面滚动不顺畅的问题</h3><ul><li>header标签添加以下代码<pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt;</code></pre></li></ul><p><br></p><h3 id="安卓端华为手机上传文件问题"><a href="#安卓端华为手机上传文件问题" class="headerlink" title="安卓端华为手机上传文件问题"></a>安卓端华为手机上传文件问题</h3><ul><li>华为某些机型无法选择图片上传</li><li>解决方法: 换手机</li></ul>]]></content>
    
    <summary type="html">
    
      移动端H5安卓、IOS端踩坑兼容记录
    
    </summary>
    
      <category term="技术" scheme="https://LittleChai.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://LittleChai.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="https://LittleChai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>常见面试题整理</title>
    <link href="https://LittleChai.github.io/2019/11/04/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <id>https://LittleChai.github.io/2019/11/04/常见面试题整理/</id>
    <published>2019-11-04T02:00:00.000Z</published>
    <updated>2019-11-04T08:52:53.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javascript面试题"><a href="#javascript面试题" class="headerlink" title="javascript面试题"></a><a href="https://www.jianshu.com/p/ad05ef11fe23" target="_blank" rel="noopener">javascript面试题</a></h2><h2 id="Vue框架"><a href="#Vue框架" class="headerlink" title="Vue框架"></a>Vue框架</h2><h3 id="使用Vue的好处"><a href="#使用Vue的好处" class="headerlink" title="使用Vue的好处"></a>使用Vue的好处</h3><ul><li>Vue两大特点：响应式编程、组件化。</li><li>Vue优势：轻量级框架、简单易学、双向数据绑定、组件化、视图、数据和结构的分离、虚拟dom、运行速度快。</li></ul><p><br></p><h3 id="MVVM定义"><a href="#MVVM定义" class="headerlink" title="MVVM定义"></a>MVVM定义</h3><ul><li>MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。【模型】指的是后端传递的数据。【视图】指的是所看到的页面。【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。</li></ul><p><br></p><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><ul><li><strong>beforeCreate</strong>(创建前)：在数据观测和初始化事件还未开始。</li><li><strong>created</strong>(创建后)：完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来。</li><li><strong>beforeMount</strong>(载入前)：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下配置：编译模版，把data里面的数据和模版生成html。注意此时还没有挂载html到页面上。</li><li><strong>mounted</strong>(载入后)： 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</li><li><strong>beforeUpdate</strong>(更新前)：在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li><li><strong>updated</strong>(更新后)：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li><strong>beforeDestroy</strong>(销毁前)： 在实例销毁之前调用。实例仍然完全可用。</li><li><strong>destroyed</strong>(销毁后)：在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li></ul><p><br></p><h3 id="Vue的响应式原理"><a href="#Vue的响应式原理" class="headerlink" title="Vue的响应式原理"></a>Vue的响应式原理</h3><ul><li>当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</li></ul><p><br></p><h3 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h3><ul><li>触发 下面这几个beforeCreate, created, beforeMount, mounted ，并在mounted的时候DOM渲染完成。</li></ul><p><br></p><h3 id="Vue中data必须是一个函数"><a href="#Vue中data必须是一个函数" class="headerlink" title="Vue中data必须是一个函数"></a>Vue中data必须是一个函数</h3><ul><li>对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</li></ul><p><br></p><h3 id="Vue中做数据渲染的时候如何保证将数据原样输出？"><a href="#Vue中做数据渲染的时候如何保证将数据原样输出？" class="headerlink" title="Vue中做数据渲染的时候如何保证将数据原样输出？"></a>Vue中做数据渲染的时候如何保证将数据原样输出？</h3><ul><li><strong>v-text</strong>：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出。</li><li><strong>v-html</strong>：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染。</li><li><strong>｛｛｝｝</strong>：插值表达式，可以直接获取Vue实例中定义的数据或函数，使用插值表达式的时候，值可能闪烁；而使用v-html、v-text不会闪烁，有值就显示，没值就隐藏。</li></ul><p><br></p><h3 id="active-class是哪个组件的属性？"><a href="#active-class是哪个组件的属性？" class="headerlink" title="active-class是哪个组件的属性？"></a>active-class是哪个组件的属性？</h3><ul><li>vue-router模块的router-link组件。</li></ul><p><br></p><h3 id="vue-router有哪几种导航钩子？"><a href="#vue-router有哪几种导航钩子？" class="headerlink" title="vue-router有哪几种导航钩子？"></a>vue-router有哪几种导航钩子？</h3><ul><li>第一种：全局导航钩子 router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。</li><li>第二种：组件内的钩子</li><li>第三种：单独路由独享组件</li></ul><p><br></p><h3 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a>$route和$router的区别</h3><ul><li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等</li></ul><p><br></p><h3 id="vue几种常用的指令"><a href="#vue几种常用的指令" class="headerlink" title="vue几种常用的指令"></a>vue几种常用的指令</h3><ul><li>v-for 、 v-if 、v-bind、v-on、v-show、v-else、v-model、v-html</li></ul><p><br></p><h3 id="v-if-和-v-show-区别"><a href="#v-if-和-v-show-区别" class="headerlink" title="v-if 和 v-show 区别"></a>v-if 和 v-show 区别</h3><ul><li>v-if按照条件是否渲染，v-show是display的block或none</li></ul><p><br></p><h3 id="vue常用的修饰符？"><a href="#vue常用的修饰符？" class="headerlink" title="vue常用的修饰符？"></a>vue常用的修饰符？</h3><ul><li>.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用</li></ul><p><br></p><h3 id="vue-loader是什么？用途有哪些？"><a href="#vue-loader是什么？用途有哪些？" class="headerlink" title="vue-loader是什么？用途有哪些？"></a>vue-loader是什么？用途有哪些？</h3><ul><li>解析.vue文件的一个加载器，跟template/js/style转换成js模块。</li><li>用途：js可以写es6、style样式可以scss或less、template可以加jade等</li></ul><p><br></p><h3 id="computed、watch、methods的区别"><a href="#computed、watch、methods的区别" class="headerlink" title="computed、watch、methods的区别"></a>computed、watch、methods的区别</h3><ul><li>computed计算属性是用来声明式的描述一个值依赖了其它的值。当你在模板里把数据绑定到一个计算属性上时，Vue 会在其依赖的任何值导致该计算属性改变时更新 DOM。这个功能非常强大，它可以让你的代码更加声明式、数据驱动并且易于维护。</li><li>watch监听的是你定义的变量,当你定义的变量的值发生变化时，调用对应的方法。就好在div写一个表达式name，data里写入num和lastname,firstname,在watch里当num的值发生变化时，就会调用num的方法，方法里面的形参对应的是num的新值和旧值，而计算属性computed,计算的是Name依赖的值,它不能计算在data中已经定义过的变量。</li><li>methods方法，函数，绑定事件调用；不会使用缓存</li></ul><p><br></p><h3 id="什么是js的冒泡？如何阻止冒泡事件？"><a href="#什么是js的冒泡？如何阻止冒泡事件？" class="headerlink" title="什么是js的冒泡？如何阻止冒泡事件？"></a>什么是js的冒泡？如何阻止冒泡事件？</h3><ul><li>js冒泡概念：当父元素内多级子元素绑定了同一个事件，js会依次从内往外或者从外往内（？）执行每个元素的该事件，从而引发冒泡</li><li>js解决冒泡：event.stopPropagation()</li><li>vue解决冒泡： 事件.stop,例如：@click.stop=”” ,@mouseover.stop=””</li></ul><p><br></p><h3 id="vue-组件通信"><a href="#vue-组件通信" class="headerlink" title="vue 组件通信"></a>vue 组件通信</h3><ul><li><p>父组件与子组件传值</p><ul><li>父组件传给子组件：子组件通过props方法接受数据;</li></ul><pre><code class="html">//父组件 father.vue&lt;template&gt;  &lt;child :msg=&quot;message&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from &#39;./child.vue&#39;;export default {    components: {        child    },    data () {        return {            message: &#39;father message&#39;;        }    }}&lt;/script&gt;</code></pre><pre><code class="html">// 子组件 child.vue&lt;template&gt;  &lt;div&gt;{{msg}}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    props: {        msg: {            type: String,            required: true        }    }}&lt;/script&gt;</code></pre><ul><li>子组件传给父组件：$emit方法传递参数</li></ul><pre><code class="html">// 父组件 father.vue&lt;template&gt;  &lt;child @msgFunc=&quot;func&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from &#39;./child.vue&#39;;export default {    components: {        child    },    methods: {        func (msg) {            console.log(msg);        }    }}&lt;/script&gt;</code></pre><pre><code class="html">// 子组件 child.vue&lt;template&gt;  &lt;button @click=&quot;handleClick&quot;&gt;点我&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default {    props: {        msg: {            type: String,            required: true        }    },    methods () {        handleClick () {            //........            this.$emit(&#39;msgFunc&#39;);        }    }}&lt;/script&gt;</code></pre></li><li>非父子组件间的数据传递，兄弟组件传值<ul><li>eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。也可使用vuex</li></ul></li></ul><p><br></p><h3 id="Vue子组件调用父组件的方法"><a href="#Vue子组件调用父组件的方法" class="headerlink" title="Vue子组件调用父组件的方法"></a>Vue子组件调用父组件的方法</h3><ul><li>第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法</li><li>第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。</li></ul><p><br></p><h3 id="的作用是什么？"><a href="#的作用是什么？" class="headerlink" title="的作用是什么？"></a><keep-alive>的作用是什么？</keep-alive></h3><ul><li><keep-alive></keep-alive>包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。 大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</li></ul><p><br></p><h3 id="nextTick是什么？"><a href="#nextTick是什么？" class="headerlink" title="$nextTick是什么？"></a>$nextTick是什么？</h3><ul><li>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。</li></ul><p><br></p><h3 id="Promise对象是什么？"><a href="#Promise对象是什么？" class="headerlink" title="Promise对象是什么？"></a>Promise对象是什么？</h3><ul><li>Promise是异步编程的一种解决方案，它是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。promise对象是一个构造函数，用来生成Promise实例。</li><li>promise的两个特点 对象状态不受外界影响 &amp;&amp; 一旦状态改变，就不会再变，任何时候都可以得到结果（pending状态–&gt;fulfilled || pending–&gt;rejected）。</li></ul><p><br></p><h3 id="axios的特点有哪些？"><a href="#axios的特点有哪些？" class="headerlink" title="axios的特点有哪些？"></a>axios的特点有哪些？</h3><ul><li>axios是一个基于promise的HTTP库，支持promise的所有API；</li><li>它可以拦截请求和响应；</li><li>它可以转换请求数据和响应数据，并对响应回来的内容自动转换为json类型的数据；</li><li>它安全性更高，客户端支持防御XSRF；</li></ul><p><br></p><h3 id="vue中的-ref-是什么？"><a href="#vue中的-ref-是什么？" class="headerlink" title="vue中的 ref 是什么？"></a>vue中的 ref 是什么？</h3><ul><li>ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。</li></ul><p><br></p><h3 id="vue如何兼容ie"><a href="#vue如何兼容ie" class="headerlink" title="vue如何兼容ie"></a>vue如何兼容ie</h3><ul><li>babel-polyfill插件</li></ul><p><br></p><h3 id="vuex是什么？"><a href="#vuex是什么？" class="headerlink" title="vuex是什么？"></a>vuex是什么？</h3><ul><li>vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data</li><li>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</li><li>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</li><li>Vuex有5种属性: 分别是 state、getter、mutation、action、module;</li><li>state<ul><li>Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</li></ul></li><li>mutations<ul><li>mutations定义的方法动态修改Vuex 的 store 中的状态或数据。</li></ul></li><li>getters<ul><li>类似vue的计算属性，主要用来过滤一些数据。</li></ul></li><li>action<ul><li>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</li></ul></li><li>vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。</li><li>使用Vuex解决非父子组件之间通信问题</li><li>vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题。</li><li>vuex 作为数据存储中心</li><li>vuex 的 State 在单页应用的开发中本身具有一个“数据库”的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理：<ul><li>组件之间全局共享的数据</li><li>通过后端异步请求的数据</li><li>比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态。</li></ul></li></ul><h3 id="页面刷新vuex被清空解决办法？"><a href="#页面刷新vuex被清空解决办法？" class="headerlink" title="页面刷新vuex被清空解决办法？"></a>页面刷新vuex被清空解决办法？</h3><ul><li>localStorage 存储到本地再回去</li><li>重新获取接口获取数据</li></ul><p><br></p><h3 id="Vue、Angular、React的区别？"><a href="#Vue、Angular、React的区别？" class="headerlink" title="Vue、Angular、React的区别？"></a>Vue、Angular、React的区别？</h3><ul><li><p>与AngularJS的区别</p><ul><li>相同点：</li><li>都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。</li><li>不同点：</li><li>AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。</li></ul></li><li><p>与React的区别</p><ul><li>相同点：</li><li>React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。</li><li>不同点：</li><li>React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。</li></ul></li></ul><p><br></p><h3 id="localstorage和sessionstorage是什么-区别"><a href="#localstorage和sessionstorage是什么-区别" class="headerlink" title="localstorage和sessionstorage是什么?区别?"></a>localstorage和sessionstorage是什么?区别?</h3><ul><li>localstorage和sessionstorage一样都是用来存储客户端临时信息的对象，他们均只能存储字符串类型对象</li><li>localstorage生命周期是永久的，这意味着除非用户在浏览器提供的UI上清除localstorage信息，否则这些信息将永远存在。</li><li>sessionstorage生命周期为当前窗口或标签，一旦窗口或标签被永久关闭了，那么所有通过sessionstorage存储的数据也将被清空。</li><li>不同浏览器无法共享localstorage或sessionstorage中的信息。相同浏览器的不同页面可以共享相同的localstorage（页面属于相同的域名和端口），但是不同页面或标签间无法共享sessionstorage。这里需要注意的是，页面及标签仅指顶级窗口，如果一个标签页包含多个iframe标签他们属于同源页面，那么他们之间是可以共享sessionstorage的。</li></ul><p><br></p><h3 id="为什么要进行前后端分离？优势？劣势？"><a href="#为什么要进行前后端分离？优势？劣势？" class="headerlink" title="为什么要进行前后端分离？优势？劣势？"></a>为什么要进行前后端分离？优势？劣势？</h3><ul><li>优点：前端专门负责前端页面和特效的编写，后端专门负责后端业务逻辑的处理，前端追求的是页面美观、页面流畅、页面兼容等。后端追求的是三高（高并发、高可用、高性能）让他们各自负责各自的领域，让专业的人负责处理专业的事情，提高开发效率。</li><li>缺点：<ul><li>当接口发生改变的时候，前后端都需要改变。</li><li>当发生异常的时候，前后端需要联调–联调是非常浪费时间的。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      常用框架及面试题整理
    
    </summary>
    
      <category term="技术" scheme="https://LittleChai.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://LittleChai.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="https://LittleChai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>这里是LittleChai的博客</title>
    <link href="https://LittleChai.github.io/2019/06/22/%E8%BF%99%E9%87%8C%E6%98%AFLittleChai%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://LittleChai.github.io/2019/06/22/这里是LittleChai的博客/</id>
    <published>2019-06-22T08:22:00.000Z</published>
    <updated>2019-10-21T02:51:39.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><ul><li>感谢honjun大佬移植的主题</li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><h4 id="在此主题基础上我进行了一些修改"><a href="#在此主题基础上我进行了一些修改" class="headerlink" title="在此主题基础上我进行了一些修改"></a>在此主题基础上我进行了一些修改</h4><ul><li>全局的颜色由原先的橙色替换成 -&gt; 樱花色</li><li>顶部header高度修改,默认颜色修改，字体大小修改</li><li>顶部导航信息修改</li><li>首页背景遮罩删除,背景重新定位</li><li>首页视频播放按钮删除</li><li>文章视频版块删除</li><li>优化aplyer播放器宽度位置</li><li>底部显示内容精简</li><li>个人简介精简</li><li>markdown文章样式部分排版重写优化</li></ul><h4 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h4><ul><li>按钮大小调整</li><li>文章位置改变，添加阴影</li><li>侧边栏图标宽度整体增加,列宽度增加,底部信息下移</li><li>优化播放器位置显示不全的问题</li><li>番组模块显示优化</li><li>书集应用此模块二次修改</li><li>图集样式重写</li></ul><h4 id="优化-amp-新增"><a href="#优化-amp-新增" class="headerlink" title="优化&amp;新增"></a>优化&amp;新增</h4><ul><li>优化某些情况图片不显示的问题</li><li>新增valine评论插件</li></ul>]]></content>
    
    <summary type="html">
    
      基于hexo-sakura主题重新制作
    
    </summary>
    
      <category term="生活" scheme="https://LittleChai.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="笔记" scheme="https://LittleChai.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
